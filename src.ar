!<arch>
//                                              842       `
package-info.java/
SimpleGTFFeature.java/
SimpleGFFFeature.java/
GetConversation.java/
DatabaseUCSC.java/
GetFeatureBED.java/
package-info.java/
GetFeatureGTF.java/
GetSequenceUsingFasta.java/
GetSequenceUsingREST.java/
SequenceFeatureExtractor.java/
RESTensembl.java/
DatabaseEnsembl.java/
package-info.java/
DisprotEngine.java/
ModPredEngine.java/
ProteinFeatureExtractor.java/
RESTUniprot.java/
ConfigureASEvent.java/
AminoAcidMap.java/
package-info.java/
package-info.java/
FrameConvertToInt.java/
ProteinAlign.java/
ASTranslateEngine.java/
package-info.java/
EventIsoformFeature.java/
ASEventBrowserTranscriptID.java/
BatchProcess.java/
ASEventMiso.java/
ASEventBrowserExons.java/
GetTranscirpts.java/
IndexWigFix.java/
package-info.java/
TestInputExons.java/
TestInputID.java/
Test2014_6_9.java/
TestInputMiso.java/
TestReadFile.java/

GTFFeature.java/1404006139  1000  1000  100600  359       `
package ASEvent.GTFFeature;

import org.broad.tribble.Feature;

import GeneStructure.Strand;

public interface GTFFeature extends Feature {

	Strand getStrand();

	String getSource();

	String getFeature();

	String getTranscriptID();

	void setTranscriptID(String id);

	float getScore();

	int getFrame();

	String getAttribute();
}

/0              1392214153  1000  1000  100600  31        `
package ASEvent.GTFFeature;


GTFCode.java/   1404006139  1000  1000  100600  1294      `
package ASEvent.GTFFeature;

import org.broad.tribble.AsciiFeatureCodec;
import org.broad.tribble.readers.LineIterator;

import GeneStructure.Strand;

public class GTFCode extends AsciiFeatureCodec<GTFFeature> {

	public GTFCode(Class<GTFFeature> fre) {
		super(fre);
	}

	public GTFCode() {
		// this();
		super(GTFFeature.class);
	}

	@Override
	public GTFFeature decode(String string) {
		String[] arrayLine = string.split("\\t", 20);
		SimpleGTFFeature gtf = new SimpleGTFFeature();
		gtf.setChr(arrayLine[0]);
		gtf.setSource(arrayLine[1]);
		gtf.setFeature(arrayLine[2]);
		gtf.setStart(Integer.parseInt(arrayLine[3]));
		gtf.setEnd(Integer.parseInt(arrayLine[4]));
		// gtf.setScore(Float.parseFloat(arrayLine[5]));
		gtf.setScore(0);
		if (arrayLine[7].equals("."))
			gtf.setFrame(0);
		else
			gtf.setFrame(Integer.parseInt(arrayLine[7]));

		if (arrayLine[6].equals("+"))
			gtf.setStrand(Strand.POSITIVE);
		else if (arrayLine[6].equals("-"))
			gtf.setStrand(Strand.NEGATIVE);
		else
			gtf.setStrand(Strand.UNKNOWN);

		gtf.setAttribute(arrayLine[8]);

		// TODO Implement this method
		return gtf;
	}

	@Override
	public Object readActualHeader(LineIterator lineIterator) {
		// TODO Implement this method
		return null;
	}
}
/19             1404006139  1000  1000  100600  2170      `
package ASEvent.GTFFeature;

import GeneStructure.Strand;

public class SimpleGTFFeature implements GTFFeature {
	public SimpleGTFFeature() {
		super();
	}

	private Strand strand;
	private String chr;
	private int startPos;
	private int endPos;
	private String source;
	private String featureName;
	private float score;
	private String attrStr;
	private int frame;
	private String transcriptID = "";

	@Override
	public Strand getStrand() {
		// TODO Implement this method
		return strand;
	}

	@Override
	public String getSource() {
		// TODO Implement this method
		return source;
	}

	@Override
	public String getFeature() {
		// TODO Implement this method
		return featureName;
	}

	@Override
	public float getScore() {
		// TODO Implement this method
		return score;
	}

	@Override
	public int getFrame() {
		// TODO Implement this method
		return frame;
	}

	@Override
	public String getAttribute() {
		// TODO Implement this method
		return attrStr;
	}

	@Override
	public String getChr() {
		// TODO Implement this method
		return chr;
	}

	@Override
	public int getStart() {
		// TODO Implement this method
		return startPos;
	}

	@Override
	public int getEnd() {
		// TODO Implement this method
		return endPos;
	}

	public void setStart(int tstartPosition) {
		startPos = tstartPosition;
	}

	public void setEnd(int tendPosition) {
		endPos = tendPosition;
	}

	public void setChr(String tchr) {
		chr = tchr;
	}

	public void setAttribute(String tattr) {
		attrStr = tattr;
	}

	public void setFrame(int tframe) {
		frame = tframe;
	}

	public void setFeature(String tFeature) {
		featureName = tFeature;
	}

	public void setStrand(Strand tstrand) {
		strand = tstrand;
	}

	public void setScore(float tscore) {
		score = tscore;
	}

	public void setSource(String tsource) {
		source = tsource;
	}

	@Override
	public String getTranscriptID() {
		// TODO Auto-generated method stub

		return transcriptID;
	}

	@Override
	public void setTranscriptID(String id) {

		transcriptID = id;

		// TODO Auto-generated method stub

	}

}
GFFCode.java/   1404006139  1000  1000  100664  1241      `
package ASEvent.GTFFeature;

import org.broad.tribble.AsciiFeatureCodec;
import org.broad.tribble.readers.LineIterator;

import GeneStructure.Strand;

public class GFFCode extends AsciiFeatureCodec<GTFFeature> {

	public GFFCode(Class<GTFFeature> fre) {
		super(fre);
	}

	public GFFCode() {
		// this();
		super(GTFFeature.class);
	}

	@Override
	public GTFFeature decode(String string) {
		String[] arrayLine = string.split("\\t", 20);
		SimpleGTFFeature gtf = new SimpleGTFFeature();
		gtf.setChr(arrayLine[0]);
		gtf.setSource(arrayLine[2]);
		gtf.setFeature(arrayLine[1]);
		gtf.setStart(Integer.parseInt(arrayLine[3]));
		gtf.setEnd(Integer.parseInt(arrayLine[4]));
		// gtf.setScore(Float.parseFloat(arrayLine[5]));
		gtf.setScore(0);
		if (arrayLine[7].equals("."))
			gtf.setFrame(0);
		else
			gtf.setFrame(Integer.parseInt(arrayLine[7]));

		if (arrayLine[6].equals("+"))
			gtf.setStrand(Strand.POSITIVE);
		else if (arrayLine[6].equals("-"))
			gtf.setStrand(Strand.NEGATIVE);
		else
			gtf.setStrand(Strand.UNKNOWN);

		gtf.setAttribute(arrayLine[8]);

		// TODO Implement this method
		return gtf;
	}

	@Override
	public Object readActualHeader(LineIterator lineIterator) {
		// TODO Implement this method
		return null;
	}
}

GFFFeature.java/1404006139  1000  1000  100664  335       `
package ASEvent.GTFFeature;

import org.broad.tribble.Feature;

import GeneStructure.Strand;

public interface GFFFeature extends Feature {

	Strand getStrand();

	String getSource();

	String getFeature();

	String getTranscriptID();

	void setTranscriptID(String id);

	float getScore();

	int getFrame();

	String getAttribute();
}

/42             1404006139  1000  1000  100664  2043      `
package ASEvent.GTFFeature;

import GeneStructure.Strand;

public class SimpleGFFFeature implements GTFFeature {
	public SimpleGFFFeature() {
		super();
	}

	private Strand strand;
	private String chr;
	private int startPos;
	private int endPos;
	private String source;
	private String featureName;
	private float score;
	private String attrStr;
	private int frame;
	private String transcriptID = "";

	@Override
	public Strand getStrand() {
		// TODO Implement this method
		return strand;
	}

	@Override
	public String getSource() {
		// TODO Implement this method
		return source;
	}

	@Override
	public String getFeature() {
		// TODO Implement this method
		return featureName;
	}

	@Override
	public float getScore() {
		// TODO Implement this method
		return score;
	}

	@Override
	public int getFrame() {
		// TODO Implement this method
		return frame;
	}

	@Override
	public String getAttribute() {
		// TODO Implement this method
		return attrStr;
	}

	@Override
	public String getChr() {
		// TODO Implement this method
		return chr;
	}

	@Override
	public int getStart() {
		// TODO Implement this method
		return startPos;
	}

	@Override
	public int getEnd() {
		// TODO Implement this method
		return endPos;
	}

	public void setStart(int tstartPosition) {
		startPos = tstartPosition;
	}

	public void setEnd(int tendPosition) {
		endPos = tendPosition;
	}

	public void setChr(String tchr) {
		chr = tchr;
	}

	public void setAttribute(String tattr) {
		attrStr = tattr;
	}

	public void setFrame(int tframe) {
		frame = tframe;
	}

	public void setFeature(String tFeature) {
		featureName = tFeature;
	}

	public void setStrand(Strand tstrand) {
		strand = tstrand;
	}

	public void setScore(float tscore) {
		score = tscore;
	}

	public void setSource(String tsource) {
		source = tsource;
	}

	@Override
	public String getTranscriptID() {
		// TODO Auto-generated method stub

		return transcriptID;
	}

	@Override
	public void setTranscriptID(String id) {

		transcriptID = id;

		// TODO Auto-generated method stub

	}

}

/65             1404375758  1000  1000  100664  2989      `
package Utility.SequenceFeatureWrapper;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.ArrayList;

import Utility.Structuure.ConfigureASEvent;

public class GetConversation {
	// ArrayList<Float>
	public static ArrayList<Float> getConservationScore(String chr, int begPos,
			int endPos) {
		
		String conservationPath=ConfigureASEvent.configurietion.get("conservationPath");
		ArrayList<Float> result = new ArrayList<Float>();
		
		try {
		//chr = "chr1";
		String indexFileName=conservationPath+chr+".phastCons100way.wigFix.index";
		File fileIndex = new File(indexFileName);
		BufferedReader input;
		String text="";
		input = new BufferedReader(new FileReader(fileIndex));

		int startPos=-1;
		long bytes=-1;
		boolean find=false;
		
		while ((text = input.readLine()) != null) {
			String[] arrLine=text.split(" ");
			startPos=Integer.parseInt(arrLine[2].substring(6));
			bytes=Integer.parseInt(arrLine[4].substring(14));
			int length=Integer.parseInt(arrLine[5].substring(7));
				
			if(begPos>startPos&&begPos<startPos+length){
				if(begPos>startPos+length)
					return result;
				else{
					find=true;
					break;
					
				}
			}

		}
		
		
		input.close();
		if(!find)
			return result;
		String fileName=conservationPath+chr+".phastCons100way.wigFix";
		File file = new File(fileName);
		
		RandomAccessFile raf;

			raf = new RandomAccessFile(file, "rw");
/*
			String a = raf.readLine();
			String[] arrHead=a.split(" ");
			int start=-1;
			
			for(int i=0;i<arrHead.length;++i){
				if(arrHead[i].startsWith("start")){
					start=Integer.parseInt(arrHead[i].substring(6));
					System.out.println(start);
				}
			}
			
			if(begPos<start)
				return result;

			
			begPos=begPos-start;
			
			int headLength = a.length() + 1;

			System.out.println("Read full line: " + a);
			// raf.seek(headLength+1);
			 */ 
			
			//begPos=begPos-startPos;

			raf.seek(bytes + (begPos-startPos - 1) * 6);
			// raf.read((endPos-begPos+1)*6);
			byte[] b = new byte[(endPos - begPos + 1) * 6];
			raf.readFully(b, 0, (endPos - begPos + 1) * 6);
			String s = new String(b);
			String[] arrLine = s.split("\n");
			
			for (int i = 0; i < arrLine.length; ++i) {
				// System.out.println(Float.parseFloat(arrLine[i]));
				result.add(Float.parseFloat(arrLine[i]));

			}

			raf.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			System.out.println(e.getMessage());
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return result;

	}
//conservationPath
	public static void main(String[] args) {
		ConfigureASEvent.readConfigureFromFile("/home/limeng/alternative/Configure.txt");
		ArrayList<Float> result=getConservationScore("chr1", 1000, 1015);
		for(Float ite:result){
			System.out.println(ite);
			
		}
		
		
	}

}

/87             1404697450  1000  1000  100664  4142      `
package Utility.SequenceFeatureWrapper;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;

import Utility.Structuure.Tris;

public class DatabaseUCSC {
	static private boolean ifConnect = false;

	static private Connection conn = null;

	public static void connect() {
		if (ifConnect)
			return;

		try {
			conn = DriverManager
					.getConnection("jdbc:mysql://191.101.1.231/ucsc?"
							+ "user=limeng&password=6231498");

		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		ifConnect = false;

	}

	public static Tris<String, Integer, Integer> getTranscriptRegion(
			String transcirptEnsemblId) {

		connect();

		Tris<String, Integer, Integer> region = new Tris<String, Integer, Integer>();

		String sqlStr = "select chrom,txStart,txEnd from ensGene where name="
				+ "'" + transcirptEnsemblId + "'";

		Statement stmt;
		try {
			stmt = conn.createStatement();

			ResultSet rset = stmt.executeQuery(sqlStr);
			while (rset.next()) {
				String chr = rset.getString("chrom");
				int start = rset.getInt("txStart");
				int end = rset.getInt("txEnd");

				region.setValue1(chr);
				region.setValue2(start);
				region.setValue3(end);

			}
			rset.close();
			stmt.close();

		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.out.println(e);
			System.out.println(sqlStr);
		}

		return region;

	}

	public static String ucscTranscriptNameToEnsemblName(String ucscName) {
		connect();
		String ensemblTranscriptName = "";

		String sqlStr = "select value from knownToEnsembl where name=" + "'"
				+ ucscName + "'";
		Statement stmt;
		try {
			stmt = conn.createStatement();

			ResultSet rset = stmt.executeQuery(sqlStr);
			while (rset.next()) {
				ensemblTranscriptName = rset.getString("value");

			}
			rset.close();
			stmt.close();
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return ensemblTranscriptName;

	}

	public static String refseqTNameToEnsemblName(String refseqName) {
		connect();
		String ucscTranscriptName = "";

		String sqlStr = "select name from knownToRefSeq where value=" + "'"
				+ refseqName + "'";
		Statement stmt;
		try {
			stmt = conn.createStatement();

			ResultSet rset = stmt.executeQuery(sqlStr);
			while (rset.next()) {
				ucscTranscriptName = rset.getString("name");

			}
			rset.close();
			stmt.close();
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return ucscTranscriptNameToEnsemblName(ucscTranscriptName);

	}

	public static ArrayList<Tris<String,Integer,Integer>> getASRegion(String chr,int begPos,int endPos){
		connect();
		
		ArrayList<Tris<String,Integer,Integer>> resultRegions=new ArrayList<Tris<String,Integer,Integer>>();

		String sqlStr = "select chrom,chromStart,chromEnd from knownAlt where chrom="+"'"+chr+"'"+" AND chromStart<"+endPos+" AND chromEnd>"+begPos;

		Statement stmt;
		try {
			stmt = conn.createStatement();

			ResultSet rset = stmt.executeQuery(sqlStr);
			while (rset.next()) {
				Tris<String, Integer, Integer> region = new Tris<String, Integer, Integer>();

				//String chr = rset.getString("chrom");
				int start = rset.getInt("chromStart");
				int end = rset.getInt("chromEnd");
								
				region.setValue1(chr);
				region.setValue2(start);
				region.setValue3(end);
				
				resultRegions.add(region);

			}
			rset.close();
			stmt.close();

		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.out.println(e);
			System.out.println(sqlStr);
		}

		return resultRegions;
		
		
	}
	
	public static void main(String[] args){
		
		ArrayList<Tris<String,Integer,Integer>> a=getASRegion("chr1",110906515,110931859);
		for(Tris<String,Integer,Integer> ite:a){
			System.out.println(ite.getValue2());
			
			
		}
		
		
	}
	
	
}
/106            1404006139  1000  1000  100600  4867      `
package Utility.SequenceFeatureWrapper;

/*
 * get gene feature from bed
 */
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;

import org.broad.tribble.AbstractFeatureReader;
import org.broad.tribble.FeatureReader;
import org.broad.tribble.bed.BEDCodec;
import org.broad.tribble.bed.BEDFeature;
import org.broad.tribble.bed.FullBEDFeature;
import org.broad.tribble.index.Index;
import org.broad.tribble.index.IndexFactory;
import org.broad.tribble.index.linear.LinearIndex;

public class GetFeatureBED {
	public GetFeatureBED() {
		super();
	}

	String annoRoot = "";
	Index index;
	private FeatureReader<BEDFeature> source;

	public class ComparatorBED implements Comparator<Object> {

		@Override
		public int compare(Object object1, Object object2) {
			// TODO Implement this method
			String line1 = (String) object1;
			String line2 = (String) object2;
			String[] arrayLine1 = line1.split("\\t");
			String[] arrayLine2 = line2.split("\\t");
			String chr1 = arrayLine1[0];
			String chr2 = arrayLine2[0];
			if (chr1.length() != chr2.length())
				return chr1.length() - chr2.length();

			if (!chr1.equals(chr2))
				for (int i = 0; (i < chr1.length()) && (i < chr2.length()); ++i) {
					if (chr1.charAt(i) != chr2.charAt(i))
						return chr1.charAt(i) - chr2.charAt(i);
				}

			long beg1 = Long.parseLong(arrayLine1[1]);
			long beg2 = Long.parseLong(arrayLine2[1]);
			if (beg1 != beg2)
				return (int) (beg1 - beg2);

			// if (chr1.equals(chr2) && beg1 == beg2)
			return 0;
		}

	}

	void sortBed(String inputFileName, String outputFileName) {
		try {

			File in = new File(inputFileName);
			File out = new File(outputFileName);
			BufferedReader input = new BufferedReader(new FileReader(in));

			ArrayList<String> content = new ArrayList<String>();
			String line;
			while ((line = input.readLine()) != null) {
				content.add(line);
			}

			Collections.sort(content, (new ComparatorBED()));

			FileWriter fileWriter = new FileWriter(out);

			for (String ite : content) {
				fileWriter.write(ite + "\n");

			}
			input.close();

			fileWriter.close();

		} catch (FileNotFoundException e) {
			System.out.println(e.getMessage());
		} catch (IOException e) {
			System.out.println(e.getMessage());
		}

	}

	public void test(String fileName) {
		// String fileName = "F:\\AS-pipeline\\data\\anno\\sortmm9.bed";
		LinearIndex t = (LinearIndex) IndexFactory.createLinearIndex(new File(
				fileName), new BEDCodec());
		System.out.println(t.containsChromosome("chr1"));

		try {
			Iterator<BEDFeature> iter = (Iterator<BEDFeature>) source.query(
					"chr2", 1, 100000000);
			System.out.println(iter.next().getName());

			// List<Block> x = t.getBlocks("chr2", 1, 10027979);
			// t.getBlocks(arg0, arg1, arg2)
			// System.out.println();
		} catch (IOException e) {
			System.out.println(e.getMessage());
		}
		// LinkedHashSet<String> x=t.getSequenceNames();
		// Iterator itr = x.iterator();
		// while(itr.hasNext()){
		// System.out.println(itr.next());
		// }
	}

	public void createIndex(String org) {
		File bed = new File(annoRoot);
		String[] names = bed.list();
		String fileName = annoRoot + names[0];
		index = IndexFactory.createIntervalIndex(new File(fileName),
				new BEDCodec());
		source = (FeatureReader<BEDFeature>) AbstractFeatureReader
				.getFeatureReader(fileName, new BEDCodec(), index);

	}

	public String getGeneName(String chr, long beg, long end) {
		String result = "";

		try {
			Iterator<BEDFeature> iter = source.query(chr, (int) beg, (int) end);
			while (iter.hasNext()) {
				result += iter.next().getName() + "\n";
			}

		} catch (IOException e) {
			System.out.println(e.getMessage());
		}
		return result;

	}

	public ArrayList<List<FullBEDFeature.Exon>> getExons(String chr, long beg,
			long end) {
		// String result="";
		ArrayList<List<FullBEDFeature.Exon>> exons = new ArrayList<List<FullBEDFeature.Exon>>();
		try {
			Iterator<BEDFeature> iter = source.query(chr, (int) beg, (int) end);
			while (iter.hasNext()) {
				// result+=iter.next().getName()+"\n";
				exons.add(iter.next().getExons());

			}

		} catch (IOException e) {
			System.out.println(e.getMessage());
		}
		return exons;

	}

	public static void main(String[] args) {

		GetFeatureBED bed = new GetFeatureBED();
		// bed.sortBed("F:\\AS-pipeline\\data\\anno\\mm9.bed","F:\\AS-pipeline\\data\\anno\\sortmm9.bed");
		bed.test("F:\\AS-pipeline\\data\\anno\\sortmm9.bed");

	}

}

/126            1392213657  1000  1000  100600  43        `
package Utility.SequenceFeatureWrapper;


/145            1408084549  1000  1000  100600  8809      `
package Utility.SequenceFeatureWrapper;

import ASEvent.GTFFeature.GTFCode;
import ASEvent.GTFFeature.GTFFeature;
import Utility.Structuure.ConfigureASEvent;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;

import org.broad.tribble.AbstractFeatureReader;
import org.broad.tribble.FeatureReader;
import org.broad.tribble.index.Index;
import org.broad.tribble.index.IndexFactory;

public class GetFeatureGTF {

	public GetFeatureGTF() {
		super();
		annoRoot = ConfigureASEvent.getConfigure().get("annoPath");
		// createIndex("mm9");

	}

	String annoRoot = "";
	Index index;
	private FeatureReader<GTFFeature> source;

	// static ComparatorGTF comGTF=new ComparatorGTF();

	private class ComparatorGTFLines implements Comparator<Object> {

		@Override
		public int compare(Object object1, Object object2) {
			String line1 = (String) object1;
			String line2 = (String) object2;
			String[] arrayLine1 = line1.split("\\t");
			String[] arrayLine2 = line2.split("\\t");
			String chr1 = arrayLine1[0];
			String chr2 = arrayLine2[0];
			if (chr1.length() != chr2.length())
				return chr1.length() - chr2.length();

			if (!chr1.equals(chr2))
				for (int i = 0; (i < chr1.length()) && (i < chr2.length()); ++i) {
					if (chr1.charAt(i) != chr2.charAt(i))
						return chr1.charAt(i) - chr2.charAt(i);
				}

			long beg1 = Long.parseLong(arrayLine1[3]);
			long beg2 = Long.parseLong(arrayLine2[3]);
			if (beg1 != beg2)
				return (int) (beg1 - beg2);

			// if (chr1.equals(chr2) && beg1 == beg2)
			return 0;
		}

	}

	private class ComparatorGTF implements Comparator<GTFFeature> {

		@Override
		public int compare(GTFFeature object1, GTFFeature object2) {

			return object1.getStart() - object2.getStart();

			// if (chr1.equals(chr2) && beg1 == beg2)
			// return 0;

		}

	}

	void sortGTF(String inputFileName, String outputFileName) {
		try {

			File in = new File(inputFileName);
			File out = new File(outputFileName);
			BufferedReader input = new BufferedReader(new FileReader(in));

			ArrayList<String> content = new ArrayList<String>();
			String line;
			while ((line = input.readLine()) != null) {
				content.add(line);
			}

			Collections.sort(content, (new ComparatorGTFLines()));

			FileWriter fileWriter = new FileWriter(out);

			for (String ite : content) {
				fileWriter.write(ite + "\n");

			}
			input.close();

			fileWriter.close();

		} catch (FileNotFoundException e) {
			System.out.println(e.getMessage());
		} catch (IOException e) {
			System.out.println(e.getMessage());
		}

	}

	public void createIndex(String org) {
		File gtf = new File(annoRoot);
		String[] names = gtf.list();
		String fileName = annoRoot + names[0];
		index = IndexFactory.createIntervalIndex(new File(fileName),
				new GTFCode());
		source = (FeatureReader<GTFFeature>) AbstractFeatureReader
				.getFeatureReader(fileName, new GTFCode(), index);

	}

	public ArrayList<String> getCDSInformation(String chr, int beg, int end) {
		ArrayList<String> cdss = new ArrayList<String>();

		try {
			Iterator<GTFFeature> iter = source.query(chr, beg, end);
			while (iter.hasNext()) {
				GTFFeature feature = iter.next();
				String name = feature.getFeature();
				if (name.equals("CDS")) {
					String cds = "";
					cds += feature.getStart() + "\t" + feature.getEnd() + "\t"
							+ feature.getFrame() + "\t";

					String attr = feature.getAttribute();
					String[] attLine = attr.split("\\;");
					for (int i = 0; i < attLine.length; ++i) {
						if (attLine[i].contains("transcript_id"))
							cds += attLine[i];
					}

					cdss.add(cds);
				}

			}

		} catch (IOException e) {
			System.out.println(e.getMessage());
		}
		return cdss;
	}

	public ArrayList<GTFFeature> getGTFFeaturesCDS(String chr, int beg, int end) {
		ArrayList<GTFFeature> features = new ArrayList<GTFFeature>();

		try {
			Iterator<GTFFeature> iter = source.query(chr, beg, end);
			while (iter.hasNext()) {
				GTFFeature f = iter.next();
				String feature = f.getFeature();
				if ("CDS".equalsIgnoreCase(feature))
					features.add(f);

			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return features;

	}

	public String geneName(String chr, int beg, int end) {
		// TODO Auto-generated method stub
		String geneName = "";

		try {
			Iterator<GTFFeature> iter = source.query(chr, beg, end);
			while (iter.hasNext()) {
				GTFFeature feature = iter.next();
				// String name=feature.getFeature();

				String attr = feature.getAttribute();
				String[] attLine = attr.split("\\;");
				for (int i = 0; i < attLine.length; ++i) {
					if (attLine[i].contains("gene_id")) {
						// cds+=attLine[i];
						geneName = attLine[i].substring(7);

					}
					// cdss.add(cds);
				}

			}

		} catch (IOException e) {
			System.out.println(e.getMessage());
		}

		// System.out.println("gene name="+geneName);
		geneName = geneName.substring(1, geneName.length() - 1);
		return geneName;
	}

	public ArrayList<String> getTranscriptIDs(String chr, int beg, int end) {
		// TODO Auto-generated method stub
		// TODO Auto-generated method stub
		ArrayList<String> transcriptIDs = new ArrayList<String>();

		try {
			Iterator<GTFFeature> iter = source.query(chr, beg, end);
			while (iter.hasNext()) {
				GTFFeature feature = iter.next();
				// String name=feature.getFeature();

				String attr = feature.getAttribute();
				String[] attLine = attr.split("\\;");
				for (int i = 0; i < attLine.length; ++i) {
					if (attLine[i].contains("transcript_id")) {
						// cds+=attLine[i];
						String t = attLine[i].substring(15);
						t = t.substring(1, t.length() - 1);

						transcriptIDs.add(t);

					}
					// cdss.add(cds);
				}

			}

		} catch (IOException e) {
			System.out.println(e.getMessage());
		}

		// System.out.println("gene name="+geneName);
		return transcriptIDs;

	}

	public void test(String fileName) {
		// String fileName = "F:\\AS-pipeline\\data\\anno\\sortmm9.bed";
		// LinearIndex t = (LinearIndex)IndexFactory.createLinearIndex(new
		// File(fileName), new GTFCode());
		index = IndexFactory.createIntervalIndex(new File(fileName),
				new GTFCode());

		source = (FeatureReader<GTFFeature>) AbstractFeatureReader
				.getFeatureReader(fileName, new GTFCode(), index);

		System.out.println(index.containsChromosome("1"));

		try {
			Iterator<GTFFeature> iter = source.query("2", 1, 100000);
			System.out.println(iter.next().getFeature());

			// List<Block> x = t.getBlocks("chr2", 1, 10027979);
			// t.getBlocks(arg0, arg1, arg2)
			// System.out.println();
		} catch (IOException e) {
			System.out.println(e.getMessage());
		}
		// LinkedHashSet<String> x=t.getSequenceNames();
		// Iterator itr = x.iterator();
		// while(itr.hasNext()){
		// System.out.println(itr.next());
		// }
	}

	public static void main(String[] args) {
		ConfigureASEvent
				.readConfigureFromFile("/home/limeng/alternative/Configure.txt");

		GetFeatureGTF gtf = new GetFeatureGTF();

		// gtf.sortGTF("/home/limeng/alternative/anno/ensemble-mm9.gtf",
		// "/home/limeng/alternative/anno/ensemble-mm9-sort.gtf");
		String inputFileName="/home/limeng/drugresistent/gtf/hg19_ccds.gtf";
		String outputFileName="/home/limeng/drugresistent/gtf/hg19_ccds_sort.gtf";
		
		//gtf.createIndex("");
		//ArrayList<String> ids = gtf
		//		.getTranscriptIDs("chr2", 22802096, 22812638);
		//for (int i = 0; i < ids.size(); ++i) {
		//	System.out.println(ids.get(i));
		//}
		gtf.sortGTF(inputFileName, outputFileName);
		// gtf.test(outputFileName);
		// gtf.createIndex("");
		// Iterator<String> ite=gtf.getCDSInformation("chr2",
		// 149945561,149945687).iterator();
		// while(ite.hasNext())
		// System.out.println(ite.next());
	}

	public static ArrayList<GTFFeature> getGTFFeatures(String gff) {

		// ArrayList<String> gffLines=new ArrayList<String>();
		ArrayList<GTFFeature> gtfFeatures = new ArrayList<GTFFeature>();
		GTFCode GFFCode = new GTFCode();

		String[] lines = gff.split("\n");
		for (int i = 0; i < lines.length; ++i) {
			// gffLines.add(lines[i]);
			if (lines[i].startsWith("#"))
				continue;

			gtfFeatures.add(GFFCode.decode(lines[i]));

		}

		Collections
				.sort(gtfFeatures, (new GetFeatureGTF().new ComparatorGTF()));

		return gtfFeatures;

	}

}

/165            1410426173  1000  1000  100600  2994      `
package Utility.SequenceFeatureWrapper;

import Utility.Structuure.ConfigureASEvent;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.HashMap;

import net.sf.picard.reference.FastaSequenceIndex;
import net.sf.picard.reference.IndexedFastaSequenceFile;

public class GetSequenceUsingFasta {
	public GetSequenceUsingFasta() {
		super();
		fastaPath = ConfigureASEvent.configurietion.get("FastaFilesPath");

	}

	static String fastaPath = "";

	private HashMap<String, IndexedFastaSequenceFile> faiGenome = new HashMap<String, IndexedFastaSequenceFile>();

	public String getSequence(String chr, int strart, int end) {

		byte[] seq = faiGenome.get(chr).getSubsequenceAt(chr, strart, end)
				.getBases();
		String str = new String(seq);
		return str;

	}

	public void generateFaiGenome() {
		String rootPath = fastaPath;
		File file = new File(rootPath);
		String[] pathList = file.list();
		try {
			for (int i = 0; i < pathList.length; ++i) {
				String fasta = rootPath + pathList[i];
				if (!fasta.endsWith(".fa"))
					continue;

				File fastaFile = new File(fasta);
				File indexFile = new File(fasta + ".fai");
				IndexedFastaSequenceFile testFai;
				//System.out.println(indexFile.getName());
				if (indexFile.exists())
					testFai = new IndexedFastaSequenceFile(fastaFile,
							new FastaSequenceIndex(indexFile));
				else {

					// testFai = new IndexedFastaSequenceFile(fastaFile);
					Process p = Runtime.getRuntime().exec(
							"/usr/bin/samtools faidx " + fasta);
					Thread.sleep(2 * 1000);
					System.out.println(fasta);
					p.waitFor();
					testFai = new IndexedFastaSequenceFile(fastaFile,
							new FastaSequenceIndex(indexFile));

				}

				// String chr = pathList[i].split("\\.", 3)[0];
				String chr = pathList[i].substring(0, pathList[i].length() - 3);
				faiGenome.put(chr, testFai);

			}
		} catch (FileNotFoundException e) {

			e.printStackTrace();
			System.out.println(e.getMessage());
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	public void testTbi() {

	}

	public void testFai() throws FileNotFoundException {
		// File fastaFile = new
		// File("F:\\AS-pipeline\\data\\mm9\\fasta\\chr1.fa");
		// IndexedFastaSequenceFile testFai = new
		// IndexedFastaSequenceFile(fastaFile);
		// ReferenceSequence x = testFai.getSubsequenceAt("chr1", 0, 100);
		// System.out.println(x.getBases()[3]);
		// String.format();

	}

	// IndexedGenome index= IndexedGenome.readIndex(indexFile);
	public static void main(String[] args) throws FileNotFoundException {
		GetSequenceUsingFasta name = new GetSequenceUsingFasta();
		// name.testFai();
		name.generateFaiGenome();
		System.out.println(name.getSequence("chr1", 1, 10000));

	}

}
/193            1404006139  1000  1000  100600  1754      `
package Utility.SequenceFeatureWrapper;

/*
 * get sequence from UCSC DAS server
 */

import Utility.Algorithm.REST;

import java.io.IOException;

public class GetSequenceUsingREST {
	public GetSequenceUsingREST() {
		super();
	}

	static String serverString = "http://genome.ucsc.edu/cgi-bin/das/";

	//
	public static String getDNASeg(String org, String chr, int beg, int end) {
		// String qstr = serverString+"ce6/dna?segment=chrII:1,100000";

		String quer = serverString + org + "/" + "dna?segment=" + chr + ":"
				+ beg + "," + end;
		String result = "";
		result = REST.getResultLoop(quer);
		System.out.println(quer);
		System.out.println(result);

		result = passXML(result, end - beg + 1);

		return result;
	}

	static String passXML(String str, int length) {
		int end = str.indexOf("</DNA>");
		String searchTerm = "<DNA length=\"" + length + "\">";
		int beg = str.indexOf(searchTerm);

		// int beg=end-length;
		str = str.substring(beg + searchTerm.length(), end);
		return str.replaceAll("\\n", "");// cut the return symbol
	}

	public static String getSequenceEnsembl(String chr, int begPos, int endPos) {
		String ensemblStr = "http://beta.rest.ensembl.org/sequence/region/human/";

		String querl = ensemblStr + chr + ":" + begPos + ":" + endPos;
		querl = querl + "?content-type=text/plain";

		System.out.println(querl);

		String dna = REST.getResultLoop(querl);

		return dna.substring(0, dna.length() - 1);
	}

	public static void main(String args[]) throws IOException {

		System.out.println(GetSequenceUsingREST.getDNASeg("hg19", "chr1",
				1100000, 1110000));
		// for( int i=0;i<12;++i)
		// result+=threadfunct(t);
		// ������
		// lock
	}
}
/220            1410425507  1000  1000  100664  3020      `
package Utility.SequenceFeatureWrapper;

import java.util.ArrayList;

import ASEvent.GTFFeature.GTFFeature;
import Utility.Structuure.ConfigureASEvent;
import Utility.Structuure.Tris;

public class SequenceFeatureExtractor {
	/*
	 * fai index
	 */
	public static boolean faisInit = false;
	public static GetSequenceUsingFasta fais;

	/*
	 * gtf index
	 */
	public static boolean gtfInit = false;
	public static GetFeatureGTF gtf;

	public static void init() {
		if (!gtfInit) {
			gtf = new GetFeatureGTF();
			gtf.createIndex("");
			gtfInit = true;
		}
		if (!faisInit) {
			fais = new GetSequenceUsingFasta();
			fais.generateFaiGenome();
			faisInit = true;
		}
	}

	public static String getSequence(String org, String chrosome, int begPos,
			int endPos) {
		init();

		if (ConfigureASEvent.configurietion.get("FetchSeqOnline").equals(
				"FALSE")) {

			return fais.getSequence(chrosome, begPos, endPos);

		} else {
			return GetSequenceUsingREST.getSequenceEnsembl(chrosome, begPos,
					endPos);

		}

	}

	public static String getGeneName(String chromsome, int begPos, int endPos) {
		init();
		String id = gtf.geneName("chr" + chromsome, begPos, endPos);

		return id;
	}

	public static ArrayList<String> getCDSInformation(String org,
			String chrosome, int begPos, int endPos) {
		init();

		return gtf.getCDSInformation(chrosome, begPos, endPos);

	}

	public static ArrayList<String> getTranscriptIDs(String chr, int beg,
			int end) {
		// TODO Auto-generated method stub
		init();

		return gtf.getTranscriptIDs("chr" + chr, beg, end);

	}

	public static ArrayList<GTFFeature> getTranscriptsOfATranscript(
			String transcriptID) {
		init();
		Tris<String, Integer, Integer> geneRegion = DatabaseUCSC
				.getTranscriptRegion(transcriptID);
		// geneRegion.setValue1("chr"+geneRegion.getValue1());
		return gtf.getGTFFeaturesCDS(geneRegion.getValue1(),
				geneRegion.getValue2(), geneRegion.getValue3());

		// String gffContent=RESTEnsembl.getGFF(geneEnsemblID);
		// ArrayList<GTFFeature>
		// gtfFeatures=GetFeatureGTF.getGTFFeatures(gffContent);
		// return gtfFeatures;

	}

	public static ArrayList<Tris<String,Integer,Integer>> getASRegions(String chr,int begPos,int endPos){
		return DatabaseUCSC.getASRegion(chr,begPos,endPos);
		
	}
	
	public static ArrayList<Float> getConservationScore(String chr,int begPos,int endPos){
		return GetConversation.getConservationScore(chr, begPos, endPos);
		
	}
	
	public static void main(String[] args) {
		String configureFileName = "/home/limeng/alternative/Configure.txt";

		ConfigureASEvent.readConfigureFromFile(configureFileName);

		ArrayList<GTFFeature> gtfFeatures = SequenceFeatureExtractor
				.getTranscriptsOfATranscript("ENST00000392322");
		for (int i = 0; i < gtfFeatures.size(); ++i) {
			GTFFeature fea = gtfFeatures.get(i);

			System.out.println(fea.getChr());
			System.out.println(fea.getStart());
			System.out.println(fea.getEnd());
			System.out.println(fea.getAttribute());
			// System.out.println(fea.getChr());

		}

	}

}
/251            1404006139  1000  1000  100664  5717      `
package Utility.SequenceFeatureWrapper;

import java.io.ByteArrayInputStream;
import java.io.IOException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import Utility.Algorithm.REST;
import Utility.Structuure.Quar;

public class RESTensembl {

	static String querl1 = "http://beta.rest.ensembl.org/lookup/symbol/homo_sapiens/";
	static String querl2 = "?content-type=text/xml";

	static String querlRegionGene = "http://beta.rest.ensembl.org/feature/region/human/";

	static String querlGeneID = "http://beta.rest.ensembl.org/feature/id/";// ENST00000288602?feature=gene;content-type=text/xml;

	public static Quar<String, String, Integer, Integer> getEnsembleGeneNameUsingGenericGeneName(
			String geneName) {
		String querl = querl1 + geneName + querl2;

		String result = REST.getResultLoop(querl);

		// System.out.println(result);
		return passXML(result);
	}

	public static Quar<String, String, Integer, Integer> passXML(String xml) {

		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		DocumentBuilder db;

		Quar<String, String, Integer, Integer> geneInformation = new Quar<String, String, Integer, Integer>();

		try {
			db = dbf.newDocumentBuilder();

			Document doc;
			doc = db.parse(new InputSource(new ByteArrayInputStream(xml
					.getBytes("utf-8"))));

			// System.out.println(x);
			// MDebug.output(xml);

			NodeList rootList;

			doc.getDocumentElement().normalize();
			rootList = doc.getElementsByTagName("data");
			for (int i = 0; i < rootList.getLength(); ++i) {
				Node tmpNode = rootList.item(i);
				Element e = (Element) tmpNode;
				String name = e.getAttribute("id");
				String chr = e.getAttribute("seq_region_name");
				int start = Integer.parseInt(e.getAttribute("start"));
				int end = Integer.parseInt(e.getAttribute("end"));

				geneInformation.setValue1(name);
				geneInformation.setValue2(chr);

				geneInformation.setValue3(start);
				geneInformation.setValue4(end);

			}

		} catch (SAXException e) {
			System.out.println(e.getMessage());
		} catch (ParserConfigurationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();

		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return geneInformation;
	}

	public static Quar<String, String, Integer, Integer> getGeneName(
			String chr, int beg, int end) {
		String querl = querlRegionGene + chr + ":" + beg + "-" + end
				+ "?feature=gene;content-type=text/xml";

		String xml = REST.getResultLoop(querl);

		Quar<String, String, Integer, Integer> geneName = passXMLGene(xml);

		return geneName;
	}

	private static Quar<String, String, Integer, Integer> passXMLGene(String xml) {
		// TODO Auto-generated method stub
		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		DocumentBuilder db;

		Quar<String, String, Integer, Integer> geneInformation = new Quar<String, String, Integer, Integer>();

		try {
			db = dbf.newDocumentBuilder();

			Document doc;
			doc = db.parse(new InputSource(new ByteArrayInputStream(xml
					.getBytes("utf-8"))));

			// System.out.println(x);
			// MDebug.output(xml);

			NodeList rootList;

			doc.getDocumentElement().normalize();
			rootList = doc.getElementsByTagName("data");
			for (int i = 0; i < 1; ++i) {
				Node tmpNode = rootList.item(i);
				Element e = (Element) tmpNode;
				String name = e.getAttribute("ID");
				String chr = e.getAttribute("seq_region_name");
				int start = Integer.parseInt(e.getAttribute("start"));
				int end = Integer.parseInt(e.getAttribute("end"));

				geneInformation.setValue1(name);
				geneInformation.setValue2(chr);

				geneInformation.setValue3(start);
				geneInformation.setValue4(end);

			}

		} catch (SAXException e) {
			System.out.println(e.getMessage());
		} catch (ParserConfigurationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();

		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return geneInformation;
	}

	public static String getGFF(String transcriptId) {

		String querlBeg = "http://beta.rest.ensembl.org/feature/id/";
		String querlEnd = "?feature=cds;content-type=text/x-gff3";
		String querl = querlBeg + transcriptId + querlEnd;

		String result = REST.getResultLoop(querl);
		return result;
	}

	public static String convertTransciptIDToGeneID(String transciptID) {
		querlGeneID = querlGeneID + transciptID
				+ "?feature=gene;content-type=text/xml";
		String xml = REST.getResultLoop(querlGeneID);

		return passXMLGene(xml).getValue1();

	}

	public static void main(String[] args) {

		convertTransciptIDToGeneID("ENST00000455263");

		System.out.println(getGFF("ENST00000455263"));
		// Quar<String,String,Integer,Integer>
		// s=getEnsembleGeneNameUsingGenericGeneName("CLIC2");
		/*
		 * System.out.println(s.getValue1()); System.out.println(s.getValue2());
		 * System.out.println(s.getValue3()); System.out.println(s.getValue4());
		 */
		/*
		 * Quar<String, String, Integer, Integer> s = getGeneName("17",
		 * 7565097,7590856); System.out.println(s.getValue1());
		 * System.out.println(s.getValue2()); System.out.println(s.getValue3());
		 * System.out.println(s.getValue4()); Quar<String, String, Integer,
		 * Integer> s=getGeneName("9",45675583,45675715);
		 * System.out.println(s.getValue1()); System.out.println(s.getValue2());
		 * System.out.println(s.getValue3()); System.out.println(s.getValue4());
		 */

	}

}

/269            1404006139  1000  1000  100664  3869      `
package Utility.SequenceFeatureWrapper;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import Utility.Structuure.Tris;

public class DatabaseEnsembl {

	static private boolean ifConnect = false;

	static private Connection conn = null;

	public static void connect() {

		try {
			conn = DriverManager
					.getConnection("jdbc:mysql://191.101.1.231/ensembl?"
							+ "user=limeng&password=6231498");

		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

	}

	public static String getTranscriptDatabaseId(String transcriptId) {
		if (!ifConnect) {
			connect();
		}

		String transcriptDatabaseId = "";
		String sqlStr = "select transcript_id from transcript where stable_id="
				+ transcriptId;
		Statement stmt;
		try {
			stmt = conn.createStatement();

			ResultSet rset = stmt.executeQuery(sqlStr);
			while (rset.next()) {
				transcriptDatabaseId = rset.getString("transcript_id");

			}

		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();

		}

		return transcriptDatabaseId;

	}

	public static Tris<String, Integer, Integer> getTranscriptRegion(
			String transcirptEnsemblId) {

		if (!ifConnect) {
			connect();
		}

		Tris<String, Integer, Integer> region = new Tris<String, Integer, Integer>();

		String sqlStr = "select seq_region_id,seq_region_start,seq_region_end from transcript where stable_id="
				+ "'" + transcirptEnsemblId + "'";

		String seqRegionId = "";

		Statement stmt;
		try {
			stmt = conn.createStatement();

			ResultSet rset = stmt.executeQuery(sqlStr);
			while (rset.next()) {
				int start = rset.getInt("seq_region_start");
				int end = rset.getInt("seq_region_end");
				region.setValue2(start);
				region.setValue3(end);
				seqRegionId = rset.getString("seq_region_id");

			}
			rset.close();
			stmt.close();

			sqlStr = "select name from seq_region where seq_region_id="
					+ seqRegionId;
			stmt = conn.createStatement();

			rset = stmt.executeQuery(sqlStr);
			while (rset.next()) {
				String chr = rset.getString("name");
				region.setValue1(chr);

			}
			rset.close();
			stmt.close();

		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.out.println(e);
			System.out.println(sqlStr);
		}

		return region;

	}

	public static Tris<String, Integer, Integer> getGeneRegion(
			String geneEnsemblId) {
		if (!ifConnect) {
			connect();
		}

		Tris<String, Integer, Integer> region = new Tris<String, Integer, Integer>();

		String sqlStr = "select seq_region_id,seq_region_start,seq_region_end from gene where stable_id="
				+ "'" + geneEnsemblId + "'";
		String seqRegionId = "";

		Statement stmt;
		try {
			stmt = conn.createStatement();

			ResultSet rset = stmt.executeQuery(sqlStr);
			while (rset.next()) {
				int start = rset.getInt("seq_region_start");
				int end = rset.getInt("seq_region_end");
				region.setValue2(start);
				region.setValue3(end);
				seqRegionId = rset.getString("seq_region_id");

			}
			rset.close();
			stmt.close();

			sqlStr = "select name from seq_region where seq_region_id="
					+ seqRegionId;
			stmt = conn.createStatement();

			rset = stmt.executeQuery(sqlStr);
			while (rset.next()) {
				String chr = rset.getString("name");
				region.setValue1(chr);

			}
			rset.close();
			stmt.close();

		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.out.println(e);
			System.out.println(sqlStr);

		}

		return region;

	}

	public static void main(String[] args) {
		// DatabaseEnsembl en = new DatabaseEnsembl();
		// en.connect();

	}

}

/291            1392209743  1000  1000  100600  42        `
package Utility.ProteinFeatureWrapper;

/310            1404006139  1000  1000  100600  4053      `
package Utility.ProteinFeatureWrapper;

/*
 * it have two methods,one is search using web,but it can max 100 proteins in one day.
 * another method is search using local software.
 */

import Utility.ASDebug;
import Utility.Algorithm.ASRandom;
import Utility.Structuure.ConfigureASEvent;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;

public class DisprotEngine {
	public DisprotEngine() {
		super();
		VSL2Broot = ConfigureASEvent.configurietion.get("VSL2Path");
		VSL2BName = ConfigureASEvent.configurietion.get("VSL2Name");
	}

	/*
	 * run using disprot local
	 */
	static String VSL2Broot = "";
	static String VSL2BName = "";

	static public String getDisProbabilityLocal(String seq,
			ArrayList<Double> disProbability) {
		VSL2Broot = ConfigureASEvent.configurietion.get("VSL2Path");
		VSL2BName = ConfigureASEvent.configurietion.get("VSL2Name");
		String javaPath = ConfigureASEvent.configurietion.get("java");

		int index = seq.indexOf("*");

		if (index != -1)
			seq = seq.substring(0, index);

		String result = "";

		String path = VSL2Broot + ASRandom.randomCharGenerator(50);
		String faPath = path + ".flat";
		try {
			FileWriter fw = new FileWriter(faPath, true);
			PrintWriter pw = new PrintWriter(fw);
			pw.println(seq);

			pw.close();
			fw.close();
			String command = javaPath + "java -jar " + VSL2Broot + VSL2BName
					+ " -s:" + faPath;
			ASDebug.output(command);

			Runtime run = Runtime.getRuntime();
			Process p = run.exec(command);

			Thread.sleep(1000 * 1);
			int times = 0; // becareful here
			while (p.getInputStream().available() <= 0) {
				Thread.sleep(1000 * 2);
				times++;
				if (times > 10000)
					break;
			}

			BufferedInputStream in = new BufferedInputStream(p.getInputStream());

			BufferedReader inBr = new BufferedReader(new InputStreamReader(in));

			String lineStr;
			String begStr = "--------------------";
			while ((lineStr = inBr.readLine()) != null) {
				if (lineStr.contains(begStr.substring(0)))
					break;
			}
			// lineStr = inBr.readLine();
			String endStr = "==============";

			while ((lineStr = inBr.readLine()) != null) {
				if (lineStr.contains(endStr.subSequence(0, endStr.length())))
					break;
				lineStr = lineStr.trim();
				result += lineStr.charAt(lineStr.length() - 1);
				String[] lineArray = lineStr.split("\\s");
				disProbability.add(Double
						.parseDouble(lineArray[lineArray.length - 2]));
			}
			inBr.close();
			in.close();

			p.destroy();

			File file = new File(faPath);
			file.deleteOnExit();

		} catch (IOException e) {
			System.out.println(e.getMessage());
		} catch (InterruptedException e) {
			System.out.println(e.getMessage());
		}
		return result;

	}

	public static void main(String args[]) throws IOException {

		String seq = "MMASTENNEKDNFMRDTASRSKKSRRRSLWIAAGAVPTAIALSLSLASPA"
				+ "AVAQSSFGSSDIIDSGVLDSITRGLTDYLTPRDEALPAGEVTYPAIEGLP"
				+ "AGVRVNSAEYVTSHHVVLSIQSAAMPERPIKVQLLLPRDWYSSPDRDFPE"
				+ "IWALDGLRAIEKQSGWTIETNIEQFFADKNAIVVLPVGGESSFYTDWNEP"
				+ "NNGKNYQWETFLTEELAPILDKGFRSNGERAITGISMGGTAAVNIATHNP"
				+ "EMFNFVGSFSGYLDTTSNGMPAAIGAALADAGGYNVNAMWGPAGSERWLE"
				+ "NDPKRNVDQLRGKQVYVSAGSGADDYGQDGSVATGPANAAGVGLELISRM"
				+ "TSQTFVDAANGAGVNVIANFRPSGVHAWPYWQFEMTQAWPYMADSLGMSR"
				+ "EDRGADCVALGAIADATADGSLGSCLNNEYLVANGVGRAQDFTNGRAYWS"
				+ "PNTGAFGLFGRINARYSELGGPDSWLGFPKTRELSTPDGRGRYVHFENGS"
				+ "IYWSAATGPWEIPGDMFTAWGTQGYEAGGLGYPVGPAKDFNGGLAQEFQG"
				+ "GYVLRTPQNRAYWVRGAISAKYMEPGVATTLGFPTGNERLIPGGAFQEFT"
				+ "NGNIYWSASTGAHYILRGGIFDAWGAKGYEQGEYGWPTTDQTSIAAGGET"
				+ "ITFQNGTIRQVNGRIEESR";
		ArrayList<Double> dis = new ArrayList<Double>();
		System.out.println(DisprotEngine.getDisProbabilityLocal(seq, dis));
		// for(Double i:dis){
		// System.out.println(i);
		// }
	}

}

/330            1404006139  1000  1000  100600  7679      `
package Utility.ProteinFeatureWrapper;

/*
 * this function doesn't support multithread
 * be carefull.
 */

import GeneStructure.Strand;
import Utility.ASDebug;
import Utility.Algorithm.ASRandom;
import Utility.Structuure.ConfigureASEvent;
import Utility.Structuure.Pair;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;

public class ModPredEngine {
	public ModPredEngine() {
		super();
		// modPredRoot = ConfigureASEvent.configurietion.get("ModPredPath");
		// modPredName = ConfigureASEvent.configurietion.get("ModPredPathName");
		// mcrPath = ConfigureASEvent.configurietion.get("mcr");

	}

	static String modPredRoot = "";
	static String modPredName = "";
	static String mcrPath = "";

	static public ArrayList<String> getPTMTable(String seq) {
		modPredRoot = ConfigureASEvent.configurietion.get("ModPredPath");
		modPredName = ConfigureASEvent.configurietion.get("ModPredPathName");
		mcrPath = ConfigureASEvent.configurietion.get("mcr");

		// modPredRoot = "F:\\AS-pipeline\\code\\ModPred_win64\\";
		// modPredName = "ModPred_win64.exe";
		int index = seq.indexOf("*");
		if (index != -1)
			seq = seq.substring(0, index);

		ArrayList<String> result = new ArrayList<String>();

		String path = modPredRoot + ASRandom.randomCharGenerator(50);
		String faPath = path + ".fasta";
		// File fa = new File(faPath);
		// /fa.deleteOnExit();

		try {
			FileWriter fw = new FileWriter(faPath, true);
			PrintWriter pw = new PrintWriter(fw);

			pw.println(">test");
			pw.println(seq);

			pw.close();
			// bw.close();
			fw.close();
			// String command=modPredRoot+"ModPred_win64.exe -i "+path;
			File f = new File(path + ".txt");
			// f.deleteOnExit();

			String command = modPredRoot + modPredName + " " + mcrPath + " "
					+ " -i " + faPath + " -o " + path + ".txt";
			ASDebug.output(command);
			Runtime run = Runtime.getRuntime();
			Process p = run.exec(command);
			// p.wait(2);
			Thread.sleep(1000 * 2);
			// p.getInputStream().
			// ASDebug.output("prepare input");
			while (!f.exists()) {
				Thread.sleep(1000 * 2);

			}

			FileInputStream fis = new FileInputStream(path + ".txt");
			int times = 0;
			while (fis.available() <= 10) {
				Thread.sleep(1000 * 2);
				times++;
				if (times > 30000000) {

					break;

				}
			}

			// while(System.in.available()<100){
			// Thread.sleep(1000 * 2);

			// }
			// System.setOut(System.out);

			// while (p.getInputStream().available() <= 0) {
			// System.setOut(System.out);

			// Thread.sleep(1000 * 2);
			// }
			// ASDebug.output("can input");

			BufferedInputStream in = new BufferedInputStream(fis);

			BufferedReader inBr = new BufferedReader(new InputStreamReader(in));
			// int i = 0;

			String lineStr;
			lineStr = inBr.readLine(); // skip first line
			while ((lineStr = inBr.readLine()) != null) {
				if (lineStr.contains("Not modified"))
					continue;

				result.add(lineStr);

				// String[] dataLine=lineStr.split("\\t");
				// ASDebug.output(i++);
			}
			inBr.close();
			in.close();
			// Runtime.getRuntime().exec(command);

			// ASDebug.output(command);

			p.destroy();
			File file = new File(faPath);
			file.deleteOnExit();
			f.deleteOnExit();

		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			ASDebug.output(e.getMessage());
		} catch (InterruptedException e) {
			ASDebug.output(e.getMessage());
		}

		return result;
	}

	static public HashMap<String, ArrayList<Pair<Integer, Double>>> parseModPredAdjustStrand(
			ArrayList<String> ptmStrings, Strand strand, int proteinLen) {
		HashMap<String, ArrayList<Pair<Integer, Double>>> ptms = new HashMap<String, ArrayList<Pair<Integer, Double>>>();

		for (String index : ptmStrings) {
			String[] arrayLine = index.split("\\t");
			if (arrayLine[arrayLine.length - 1].equals("Not modified")
					|| (arrayLine.length < 6))
				continue;

			String posStr = arrayLine[0].substring(1, arrayLine[0].length());
			int pos = Integer.parseInt(posStr);
			if (strand.equals(Strand.NEGATIVE))
				pos = proteinLen - pos;

			double score = Double.parseDouble(arrayLine[4]);

			Pair<Integer, Double> posScore = new Pair<Integer, Double>(
					new Integer(pos), new Double(score));

			// ptms.put(arrayLine[1], posScore);
			String name = arrayLine[1];
			name = name.replace("-", "_");

			if (ptms.containsKey(name)) {
				ptms.get(name).add(posScore);
			} else {
				ArrayList<Pair<Integer, Double>> tmp = new ArrayList<Pair<Integer, Double>>();
				tmp.add(posScore);
				ptms.put(name, tmp);
			}

			// ptms.put(arrayLine[1],)

		}

		return ptms;
	}

	public static void main(String args[]) throws IOException {

		String seq = "YCEKEKASSKDLRHTHGKGEPSRPARRLSESLHSADENKTESKVEREYKRRTSTPVILEGAQEETDTRDGKKQPERSETNVEETQKQKSTLKNEKYQKKDDPETHGKGLPKKEAKSAKERPEKEKAQSEDKPSSKHKHKGDSVHKMSDETELHSSEKGETEESVRKQGQQTKLSSDDRTERKSKHKSERRLSVLGRDGKPVSEYTIKTDEHARKDNKKEKHLSSEKSKAEHKSRRSSDSKLQKDALSSKQHSVTSQKRSESCSEDKCETDSTNADSSFKPEELPHKERRRTKSLLEDKVVSKSKSKGQSKQTKAAETEAQEGVTRQVTTPKPDKEKNTEDNDTERQRKFKLEDRTSEETVTDPALENTVSSAHSAQKDSGHRAKLASIKEKHKTDKDSTSSKLERKVSDGHRSRSLKHSNKDMKKKEENKPDDKNGKEVDSSHEKGRGNGPVTEKKLSRRLCENRRGSTSQEMAKEDKLVANMSGTTSSSSLQRPKKSTETTSIPEQEPMEIDSEAAVENVSELSKTEDISSNSSQQDTDFENVTKHKATAGVLKDEFRTSMVDSKPAAAVTCKSGRGLAVTSISERHADHKSTLTKKVHSQGNPSKAAPREREPIQRGAQEVSVDSEVSRKALSRAPSENEKGQKNLKGMSKTTEECGTHRNASLEYSTDSDLLSSSGSVTVVPQKESHNSNTIPVIDREAISEGGRASTSLANHSDVPNQYSTVKKSEVHKTNGSKEGNDGFTVDMPTKANGGSKRHLSEDSQATLLYSKESKISIPLADKSMSVTGDNKNINKQRSLMGTAKRESDLKVNPDIKQDSAAGEHVVDLSTRKEAETVRRKHNKEIPTDVERKTENSEVDTSARRDSAPVPQQRHGKMERGAAGSGRRDKAFIATSTEGTDKGIMLNTVKTGDATTTSSEVGEKGTALPCTSIEADEGFMMGACPKKHPLQVGAEASECTVFAAAEEGKGVVTEGFAESEILLTSSKEGESGECAVAESEDRVAGPLAAHTVQAEANVNSITTEEKDDAVTSAGSEEKCGGSACTVEGTATFIGEVESDGAVTSAGTEIRAGSLSSEDVDGSQENRIQVGPKKETEGTVTCTETKGRNDNFICLVTRVETQEQRVVTGADVVQVNAAKPQEANANQGDGSGTDGAEGESAVTSTGITEEDGEASANCTGSEDNREGCAISSETEESAESAMDSTEAKDITNAPLVAAGPCDDEGIVTSTGAKEEDDEDEGVVTSTGRGNEPGHASACTGIEESEGMMVCESGEGGAQIGPTIDHVNAEAGAATVNTNDSNVDSMSGAEKEIKDTNICSSAKGIVESSVTSALAGNSDRPPVLCGSEGPMASASSHHSDSQLTRKETVEDTTISTGLVKGSDDVLVSGEVPECEVGHMSPRKNEECDGLMASTASCDVSNKDSLAGSKSQGNGLMISTSTNACTPQISAVIDVRGGHLSTLSTEEIRDGVRVHREGFEAPMPSAVSGENSQLTASRSEEKDECAMISTSIGEEFELPISSAVTVTCAERQQPVAAVEESTTGPALVSTEDFEVPMPSAPTEAESPLASTSKEEKDECALISTSIAEECEASVFGVSRNAPSVTDGNAVISTSSVEDCEGSVSSAVPQESVCPSVIPVEETGDTAMISTSTSEGREAVMVGTIPTDDDQATTVRGEDLSDAAIISTSTAECVLTCTSLSRHEENQQATHNPEGNGGHLATKQSKCELPMPSLVAERNCKCPGPFRMGKGVGPLMAVGTRGEHDRLPVCEPSVGQGQPGTALCLGEEESHGMDCPGQDLNAKERNTLLSSVQRESKSAEAEAAGDSSTARRTVRKDSERNANSLSETNCLREPEQKPAEDTSGSTHCLTAVNPGAEADGMLPITHAALEYPDHQEPESNLKTTTKCITGQESQMPSSHTGVLSAVCHVAPCASEQEGGLPTKSDHSGTWTSEGSPEKMGHVAGARQSFHREGNLDVTLPPEDNGCGVVLLGNEESPPKGIGGLELSTGLTT";
		// modPredRoot = "F:\\AS-pipeline\\code\\ModPred_win64\\";
		// modPredName = "ModPred_win64.exe";
		String configureFileName = "/home/limeng/alternative/Configure.txt";

		// String configureFileName=args[0];
		// String org=args[1];
		// String fileName=args[2];

		ConfigureASEvent.readConfigureFromFile(configureFileName);

		ArrayList<String> t = ModPredEngine.getPTMTable(seq);
		// parseModPredAdjustStrand(t,Strand.POSITIVE,seq.length());
		for (String index : t) {
			System.out.println(index);
		}

		// System.out.println(ModPredEngine.getPTM(seq));

	}

}

PfamEngine.java/1406362903  1000  1000  100600  11440     `
package Utility.ProteinFeatureWrapper;

import Utility.ASDebug;
import Utility.Algorithm.ASRandom;
import Utility.Algorithm.REST;
import Utility.Structuure.ConfigureASEvent;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

public class PfamEngine {
	
	private static boolean ifConnect;
	
	private static Connection conn;

	public PfamEngine() {
		super();
	} /*
	 * pfam.
	 */
	
	public static void connect() {
		if (ifConnect)
			return;

		try {
			conn = DriverManager
					.getConnection("jdbc:mysql://191.101.1.231/pfam?"
							+ "user=limeng&password=6231498");

		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		ifConnect = false;

	}
	
	
	
	static String serverString1 = "http://pfam.sanger.ac.uk/search/sequence";
	static String serverString2 = "http://pfam.janelia.org/search/sequence";
	static String pfamDescriptServerString = "http://pfam.sanger.ac.uk/family/";// ?output=xml"

	static boolean server = true;

	static String serverString = "";

	static String quer;

	
	private static String getDescriptionDatabase(String pfamId){
		connect();
		
		String des = "";

		String sqlStr = "select description from pfama where pfamA_acc=" + "'"
				+ pfamId + "'";
		Statement stmt;
		try {
			stmt = conn.createStatement();

			ResultSet rset = stmt.executeQuery(sqlStr);
			while (rset.next()) {
				des = rset.getString("description");

			}
			rset.close();
			stmt.close();
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return des;
		
	}

	public static String getDescription(String pfamId) {
		String querl = pfamDescriptServerString + pfamId + "?output=xml";

		String xml = REST.getResultLoop(querl);
		return passXMLDescription(xml);

	}

	private static String passXMLDescription(String x) {
		// TODO Auto-generated method stub
		String des = "";
		try {
			DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
			DocumentBuilder db;
			// String result = "";
			try {
				db = dbf.newDocumentBuilder();

				Document doc;

				doc = db.parse(new InputSource(new ByteArrayInputStream(x
						.getBytes("utf-8"))));

				// System.out.println(x);
				ASDebug.output(x);

				NodeList rootList;

				doc.getDocumentElement().normalize();
				rootList = doc.getElementsByTagName("description");
				// result=rootList.item(0).getNodeValue();
				for (int i = 0; i < rootList.getLength(); ++i) {
					Node tmpNode = rootList.item(i);
					Element e = (Element) tmpNode;
					des = e.getTextContent();
				}
			} catch (UnsupportedEncodingException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			} catch (SAXException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
		} catch (ParserConfigurationException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		return des;
	}

	public static ArrayList<String> getPfamLocally(String seq) {
		ArrayList<String> pfamEntry = new ArrayList<String>();

		String pfamScan = ConfigureASEvent.configurietion.get("pfamScan");
		String pfamDir = ConfigureASEvent.configurietion.get("pfamA");

		String path = pfamScan + ASRandom.randomCharGenerator(50);
		try {

			FileWriter fw;

			fw = new FileWriter(path, true);

			PrintWriter pw = new PrintWriter(fw);
			pw.println(">hi");
			pw.println(seq);

			pw.close();
			fw.close();

			String command = "/usr/bin/perl -I " + pfamScan + " " + pfamScan
					+ "pfam_scan.pl -fasta " + path + " -dir " + pfamDir;// +" -outfile "+path+".txt";
			Runtime run = Runtime.getRuntime();
			ASDebug.output(command);
			// Process

			Process p = run.exec(command);
			// System.out.println(command);

			// Thread.sleep(1000 * 1);

			int times = 0; // becareful here
			// p.getErrorStream();

			while (p.getInputStream().available() <= 0) {
				Thread.sleep(1000 * 1);

				times++;
				if (times > 10000)
					break;
			}

			// path + ".txt"
			// FileInputStream fis = new FileInputStream(p.getErrorStream(path +
			// ".txt"));
			BufferedInputStream in = new BufferedInputStream(p.getInputStream());

			BufferedReader inBr = new BufferedReader(new InputStreamReader(in));

			String lineStr;
			while ((lineStr = inBr.readLine()) != null) {
				// System.out.println(lineStr);
				if (lineStr.startsWith("#"))
					continue;

				if (lineStr.length() < 40) {
					// System.out.println(lineStr);
					continue;

				}

				// System.out.println(lineStr);
				// System.out.println(lineStr);

				String[] arrLine = lineStr.split(" ");
				ArrayList<String> line = new ArrayList<String>();

				// int index=0;
				for (int i = 0; i < arrLine.length; ++i) {
					if (arrLine[i].length() == 0) {

					} else {
						line.add(arrLine[i]);
						
						// index++;
						

					}

				}

				int begPos = Integer.parseInt(line.get(1));
				int endPos = Integer.parseInt(line.get(2));
//line.set(line.size()-1,arrLine[i]+"\t"+getDescriptionDatabase(arrLine[i-1].trim().split(".")[0]));
				String pfamacc=line.get(5).substring(0, 7).trim();
				String family = line.get(5);
				String name = line.get(6)+"\t"+getDescriptionDatabase(pfamacc);

				String oneEntry = begPos + "&" + endPos + "&" + family + "&"
						+ name;

				pfamEntry.add(oneEntry);

			}

			File file = new File(path);
			file.delete();
			file.deleteOnExit();

		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();

		}
		return pfamEntry;

	}

	public static ArrayList<String> getProteinXML(String proteinSequence) {
		// String qstr = serverString+"ce6/dna?segment=chrII:1,100000";

		ArrayList<String> proteinFam = new ArrayList<String>();
		if (proteinSequence.contains("*"))
			return proteinFam;

		quer = serverString1 + "?seq=" + proteinSequence + "&output=xml";

		String x = REST.getResultLoop(quer);
		// System.out.println(x);
		ASDebug.output(x);

		if (!x.startsWith("<?xml"))
			return proteinFam;

		// int beg=x.indexOf("<result_url>");
		// int end=x.indexOf("</result_url>");
		// quer=x.substring(beg+12, end);

		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		DocumentBuilder db;
		try {
			db = dbf.newDocumentBuilder();

			// System.out.println(x);
			Document doc = db.parse(new InputSource(new ByteArrayInputStream(x
					.getBytes("utf-8"))));

			NodeList rootList;

			doc.getDocumentElement().normalize();
			rootList = doc.getElementsByTagName("result_url");

			// quer=rootList.item(0).getNodeValue();
			// quer=rootList.item(0).getNodeName();
			quer = rootList.item(0).getTextContent();

		} catch (SAXException e) {
			System.out.println(e.getMessage());
		} catch (ParserConfigurationException e) {
			System.out.println(e.getMessage());
		} catch (IOException e) {
			System.out.println(e.getMessage());
		}

		ASDebug.output(quer);

		String hmmValue = REST.getResultLoop(quer);

		// proteinFam=passHTML(x);
		proteinFam = passXML(hmmValue);

		return proteinFam;

	}

	static ArrayList<String> passXML(String x) {
		ArrayList<String> pfamEntry = new ArrayList<String>();

		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		DocumentBuilder db;
		// String result = "";
		try {
			db = dbf.newDocumentBuilder();

			Document doc = db.parse(new InputSource(new ByteArrayInputStream(x
					.getBytes("utf-8"))));
			// System.out.println(x);
			ASDebug.output(x);

			NodeList rootList;

			doc.getDocumentElement().normalize();
			rootList = doc.getElementsByTagName("match");
			// result=rootList.item(0).getNodeValue();
			for (int i = 0; i < rootList.getLength(); ++i) {
				Node tmpNode = rootList.item(i);
				Element e = (Element) tmpNode;
				// String pfamDomain = e.getAttribute("accession") + "\t"
				// + e.getAttribute("id") + "\t" + e.getAttribute("type")
				// + "\t" +
				// e.getAttribute("class")+"&"+getDescription(e.getAttribute("id"));
				String pfamDomain = e.getAttribute("accession") + "&"
						+ getDescription(e.getAttribute("id"));

				NodeList mathChild = e.getChildNodes();

				for (int g = 0; g < mathChild.getLength(); ++g) {
					Node t = mathChild.item(g);
					String nodeName = t.getNodeName();
					if (nodeName.equals("location")) {
						Element location = (Element) t;

						String start = location.getAttribute("start");
						String end = location.getAttribute("end");

						pfamEntry.add(start + "&" + end + "&" + pfamDomain);

						// break;
					}
				}

				// result = e.getAttribute("id");
				// result = e.getAttribute("type");
			}

		} catch (SAXException e) {
			System.out.println(e.getMessage());
		} catch (ParserConfigurationException e) {
			System.out.println(e.getMessage());
		} catch (IOException e) {
			System.out.println(e.getMessage());
		}

		return pfamEntry;
	}

	public static void main(String args[]) throws IOException,
			InterruptedException {
		// DNASequence x=new
		// DNASequence("cgatgcatcgtatcgtggggggggggggggggatcagctagctacgtacgtacgtacgtac");
		// System.out.println(SearchProteinUsingRest.getProteinXML(x.getRNASequence().getProteinSequence()));
		System.out.println("meng");
		ConfigureASEvent
				.readConfigureFromFile("/home/limeng/alternative/Configure.txt");

		ArrayList<String> t = PfamEngine
				.getPfamLocally("MSQWYELQQLDSKFLEQVHQLYDDSFPMEIRQYLAQWLEKQDWEHAANDVSFATIRFHDLLSQLDDQYSRFSLENNFLLQHNIRKSKRNLQDNFQEDPIQMSMIIYSCLKEERKILENAQRFNQAQSGNIQSTVMLDKQKELDSKVRNVKDKVMCIEHEIKSLEDLQDEYDFKCKTLQNREHETNGVAKSDQKQEQLLLKKMYLMLDNKRKEVVHKIIELLNVTELTQNALINDELVEWKRRQQSACIGGPPNACLDQLQNWFTIVAESLQQVRQQLKKLEELEQKYTYEHDPITKNKQVLWDRTFSLFQQLIQSSFVVERQPCMPTHPQRPLVLKTGVQFTVKLRLLVKLQELNYNLKVKVLFDKDVNERNTVKGFRKFNILGTHTKVMNMEESTNGSLAAEFRHLQLKEQKNAGTRTNEGPLIVTEELHSLSFETQLCQPGLVIDLETTSLPVVVISNVSQLPSGWASILWYNMLVAEPRNLSFFLTPPCARWAQLSEVLSWQFSSVTKRGLNVDQLNMLGEKLLGPNASPDGLIPWTRFCKENINDKNFPFWLWIESILELIKKHLLPLWNDGCIMGFISKERERALLKDQQPGTFLLRFSESSREGAITFTWVERSQNGGEPDFHAVEPYTKKELSAVTFPDIIRNYKVMAAENIPENPLKYLYPNIDKDHAFGKYYSRPKEAPEPMELDGPKGTGYIKTELISVSEV");
		for (String ite : t) {
			System.out.println(ite);
		}

	}

}
/350            1404006139  1000  1000  100664  8858      `
package Utility.ProteinFeatureWrapper;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

import GeneStructure.Strand;
import Utility.Algorithm.ProteinAlign;
import Utility.Algorithm.RESTPDB;
import Utility.SequenceFeatureWrapper.SequenceFeatureExtractor;
import Utility.Structuure.ConfigureASEvent;
import Utility.Structuure.Pair;
import Utility.Structuure.Quar;
import Utility.Structuure.Tris;

public class ProteinFeatureExtractor {

	public static String getDisProbability(String proteinSequence,
			Strand strand, ArrayList<Double> dis) {
		String disStr = DisprotEngine.getDisProbabilityLocal(proteinSequence,
				dis);

		if (strand.equals(Strand.NEGATIVE)) {
			ArrayList<Double> reverseDis = new ArrayList<Double>();
			for (int i = dis.size() - 1; i >= 0; --i) {
				reverseDis.add(dis.get(i));

			}

			dis = reverseDis;

			String reverseDisStr = "";
			for (int i = disStr.length() - 1; i > 0; --i) {
				reverseDisStr += disStr.charAt(i);

			}

			disStr = reverseDisStr;

		}

		return disStr;
	}

	// get pfam information

	public static ArrayList<Tris<Integer, Integer, String>> getPfamName(
			String proteinSenquence, Strand strand) {
		int len = proteinSenquence.length();
		ArrayList<Tris<Integer, Integer, String>> pfamValues = new ArrayList<Tris<Integer, Integer, String>>();
		ArrayList<String> pfams = PfamEngine.getProteinXML(proteinSenquence);
		for (String ite : pfams) {
			String[] lpfam = ite.split("\\t");

			if (strand.equals(Strand.POSITIVE))
				pfamValues.add(new Tris<Integer, Integer, String>(Integer
						.parseInt(lpfam[0]), Integer.parseInt(lpfam[1]),
						lpfam[2]));
			else
				pfamValues.add(new Tris<Integer, Integer, String>(len
						- Integer.parseInt(lpfam[1]) + 1, len
						- Integer.parseInt(lpfam[0]) + 1, lpfam[2]));

		}
		return pfamValues;
	}

	// get modpred information
	public static ArrayList<String> getPTMs(String proteinSequence) {
		ArrayList<String> t = ModPredEngine.getPTMTable(proteinSequence);
		return t;
		// parseModPredAdjustStrand(t,Strand.Positive,seq.length());
	}

	// get modpred information for plot
	public static HashMap<String, ArrayList<Pair<Integer, Double>>> getPTMsAdjustStrand(
			String proteinSequence, Strand strand) {
		ArrayList<String> t = ModPredEngine.getPTMTable(proteinSequence);

		return ModPredEngine.parseModPredAdjustStrand(t, strand,
				proteinSequence.length());

	}

	public static ArrayList<String> getPDBFiles(String dnaSequence) {
		ArrayList<String> files = new ArrayList<String>();
		ArrayList<String> ids = RESTPDB.fetchPDBId(dnaSequence);
		ArrayList<String> humanIds = new ArrayList<String>();

		for (String id : ids) {
			String org = RESTPDB.getEntityDescription(id);
			if (org.equals("Homo sapiens"))
				humanIds.add(id);
		}

		files = RESTPDB.fetchPDBFiles(humanIds);

		// files=RESTPDB.fetchPDBFiles(dnaSequence);

		return files;

	}

	@SuppressWarnings("resource")
	public static ArrayList<String> getPDBFilesUsingGeneName(String geneName) {
		ArrayList<String> files = new ArrayList<String>();
		InputStream fis;
		BufferedReader br;
		String line;

		String pdbFigurePath = ConfigureASEvent.getConfigure().get(
				"pdbFilePath")
				+ geneName + "/";

		File file = new File(pdbFigurePath);
		String[] pathList = file.list();
		String filePath = "";
		try {

			for (int i = 0; i < pathList.length; ++i) {
				pathList[i] = pdbFigurePath + pathList[i];

				filePath = pathList[i];

				fis = new FileInputStream(filePath);

				br = new BufferedReader(new InputStreamReader(fis,
						Charset.forName("UTF-8")));

				String oneFile = "";
				while ((line = br.readLine()) != null) {
					oneFile += line + "\n";

				}

				files.add(oneFile);
			}

		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return files;

	}

	public static ArrayList<String> getPDBProteins(ArrayList<String> files) {
		ArrayList<String> pdbProteins = new ArrayList<String>();

		for (int i = 0; i < files.size(); ++i) {
			String pdbProtein = RESTPDB.fecthPDBSeq(files.get(i));

			pdbProteins.add(pdbProtein);
		}

		return pdbProteins;

	}

	public static ArrayList<Pair<Integer, String>> getPDBFilesAnsSnpPostion(
			String dnaSequence, String proteinSequence, int tsnpPos) {
		ArrayList<Pair<Integer, String>> pdbPosFile = new ArrayList<Pair<Integer, String>>();

		ArrayList<String> files = new ArrayList<String>();
		ArrayList<Integer> snpPositions = new ArrayList<Integer>();

		files = RESTPDB.fetchPDBFiles(dnaSequence);

		ArrayList<String> pdbProteins = new ArrayList<String>();

		for (int i = 0; i < files.size(); ++i) {
			String pdbProtein = pdbProteins.get(i);

			pdbProteins.add(pdbProtein);
			int snpPos = ProteinAlign.getSNPPosition(proteinSequence,
					pdbProtein, tsnpPos);
			snpPositions.add(snpPos);
			pdbPosFile.add(new Pair<Integer, String>(snpPos, files.get(i)));

		}

		return pdbPosFile;
	}

	public static ArrayList<Pair<Integer, String>> getPTMUsingGeneName(
			String chr, int beg, int end, String asProteinSequence) {
		ArrayList<Pair<Integer, String>> uniPTMs = new ArrayList<Pair<Integer, String>>();

		// Quar<String, String, Integer, Integer> en = RESTEnsembl.getGeneName(
		// chr, beg, end);
		// ensemble gene id
		// System.out.println("ids");
		ArrayList<String> transcriptIDs = SequenceFeatureExtractor
				.getTranscriptIDs(chr, beg, end);

		if (transcriptIDs.size() == 0) {
			// System.out.println("number of ids="+transcriptIDs.size());
			return uniPTMs;
		}
		// String ensemblGeneID = transcriptIDs;
		// for(int i=0;i<transcriptIDs.size();++i)
		// System.out.println("ucsc gene id="+transcriptIDs.get(i));

		HashSet<String> ids = new HashSet<String>();

		for (int i = 0; i < transcriptIDs.size(); ++i) {

			String ensemblGeneID = transcriptIDs.get(i);

			ArrayList<String> tIds = RESTUniprot
					.convertEnsembleTransIDToUniprotIDs(ensemblGeneID);

			for (int j = 0; j < tIds.size(); ++j)
				ids.add(tIds.get(j));

		}
		// for(String id:ids)
		// System.out.println("id="+id);

		int i = 0;

		for (String id : ids) {
			ArrayList<Pair<Integer, String>> ptms = RESTUniprot
					.getPTMsUingUniprot(id);
			if (ptms.size() != 0) {
				i++;
				String sequence = RESTUniprot.getSequenceUniprot(id);
				for (Pair<Integer, String> a : ptms) {
					int p = a.getValue1();
					int newPos = ProteinAlign.getSNPPosition(sequence,
							asProteinSequence, p);
					if (newPos != -1) {
						uniPTMs.add(new Pair<Integer, String>(newPos, a
								.getValue2()));
					}

				}

			}

		}
		System.out.println("number of gene=" + i);
		return uniPTMs;
	}

	public static void main(String[] args) {
		String s = "MEEPQSDPSVEPPLSQETFSDLWKLLPENNVLSPLPSQAMDDLMLSPDDIEQWFTEDPGPDEAPRMPEAA"
				+ "PPVAPAPAAPTPAAPAPAPSWPLSSSVPSQKTYQGSYGFRLGFLHSGTAKSVTCTYSPALNKMFCQLAKT"
				+ "CPVQLWVDSTPPPGTRVRAMAIYKQSQHMTEVVRRCPHHERCSDSDGLAPPQHLIRVEGNLRVEYLDDRN"
				+ "TFRHSVVVPYEPPEVGSDCTTIHYNYMCNSSCMGGMNRRPILTIITLEDSSGNLLGRNSFEVRVCACPGR"
				+ "DRRTEEENLRKKGEPHHELPPGSTKRALPNNTSSSPQPKKKPLDGEYFTLQIRGRERFEMFRELNEALEL"
				+ "KDAQAGKEPGGSRAHSSHLKSKKGQSTSRHKKLMFKTEGPDSD";

		ArrayList<Pair<Integer, String>> t = getPTMUsingGeneName("17", 7565097,
				7590856, s);

		for (Pair<Integer, String> a : t) {
			System.out.println(a.getValue1() + "\t" + a.getValue2());

		}

	}

	public static ArrayList<String> getPfam(String proteinSenquence) {
		// TODO Auto-generated method stub
		// int len=proteinSenquence.length();
		// ArrayList<Tris<Integer,Integer,String>> pfamValues=new
		// ArrayList<Tris<Integer,Integer,String>>();

		ArrayList<String> pfams = PfamEngine.getProteinXML(proteinSenquence);

		return pfams;
	}

	// start position&end position&protein family&description
	public static ArrayList<Quar<Integer, Integer, String, String>> getPfamQuar(
			String proteinSenquence, Strand strand) {
		// int len=proteinSenquence.length();
		ArrayList<Quar<Integer, Integer, String, String>> pfamValues = new ArrayList<Quar<Integer, Integer, String, String>>();
		ArrayList<String> pfams = PfamEngine.getPfamLocally(proteinSenquence);
		for (String ite : pfams) {
			// System.out.println(ite);
			String[] lpfam = ite.split("&");
			pfamValues.add(new Quar<Integer, Integer, String, String>(Integer
					.parseInt(lpfam[0]), Integer.parseInt(lpfam[1]), lpfam[2],
					lpfam[3]));

			// pfamValues.add(new
			// Quar<Integer,Integer,String,String>(len-Integer.parseInt(lpfam[1])+1,len-Integer.parseInt(lpfam[0])+1
			// ,lpfam[2],lpfam[3]) );

		}
		return pfamValues;
	}

}
/380            1406363435  1000  1000  100664  12728     `
package Utility.ProteinFeatureWrapper;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.logging.Logger;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import Utility.Algorithm.REST;
import Utility.Structuure.Pair;
import Utility.Structuure.Quar;

public class RESTUniprot {
	private static final String UNIPROT_SERVER = "http://www.uniprot.org/";
	private static final Logger LOG = Logger.getAnonymousLogger();

	private static String run(String tool, ParameterNameValue[] params)
			throws Exception {
		StringBuilder locationBuilder = new StringBuilder(UNIPROT_SERVER + tool
				+ "/?");
		for (int i = 0; i < params.length; i++) {
			if (i > 0)
				locationBuilder.append('&');
			locationBuilder.append(params[i].name).append('=')
					.append(params[i].value);
		}
		String location = locationBuilder.toString();
		String s = REST.getResultLoop(location);
		// System.out.println(s);
		return s;
	}

	public static ArrayList<String> convertEnsembleToUniprot(
			String ensembleGeneName) {
		ArrayList<String> ids = new ArrayList<String>();
		try {
			String result = run("mapping", new ParameterNameValue[] {
					new ParameterNameValue("from", "ENSEMBL_ID"),
					new ParameterNameValue("to", "ACC"),
					new ParameterNameValue("format", "tab"),
					new ParameterNameValue("query", ensembleGeneName), });

			String[] lines = result.split("\n", 20);
			for (int i = 0; i < lines.length; ++i) {
				if (i == 0)
					continue;
				String[] line = lines[i].split(" ", 20);
				ids.add(line[1]);

			}

		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return ids;
	}

	public static String convertEnsembleProteinToUniprot(
			String ensembleProteinId) {
		String id = "";
		try {
			String result = run("mapping", new ParameterNameValue[] {
					new ParameterNameValue("from", "ENSEMBL_PRO_ID"),
					new ParameterNameValue("to", "ACC"),
					new ParameterNameValue("format", "tab"),
					new ParameterNameValue("query", ensembleProteinId), });

			String[] lines = result.split("\n", 20);
			for (int i = 0; i < lines.length; ++i) {
				if (i == 0)
					continue;
				if (lines[i].length() < 1)
					continue;
				String[] line = lines[i].split("\t", 20);
				id = (line[1]);

			}

		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return id;
	}

	public static ArrayList<String> convertUniprotIdToPDBID(String uniprotId) {
		ArrayList<String> ids = new ArrayList<String>();
		try {
			String result = run("mapping", new ParameterNameValue[] {
					new ParameterNameValue("from", "ACC"),
					new ParameterNameValue("to", "PDB_ID"),
					new ParameterNameValue("format", "tab"),
					new ParameterNameValue("query", uniprotId), });

			String[] lines = result.split("\n", 20);
			for (int i = 0; i < lines.length; ++i) {
				if (i == 0)
					continue;
				if (lines[i].length() < 1)
					continue;
				String[] line = lines[i].split("\t", 20);
				ids.add(line[1]);

			}

		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return ids;
	}

	public static ArrayList<String> convertEnsembleGeneIDToUniprotIDs(
			String geneEnsembleId) {
		ArrayList<String> uniprotIDs = new ArrayList<String>();

		try {
			String result = run("mapping", new ParameterNameValue[] {
					new ParameterNameValue("from", "ENSEMBL_ID"),
					new ParameterNameValue("to", "ACC"),
					new ParameterNameValue("format", "tab"),
					new ParameterNameValue("query", geneEnsembleId), });

			String[] lines = result.split("\n", 20);
			for (int i = 0; i < lines.length; ++i) {
				if (i == 0)
					continue;
				if (lines[i].length() < 1)
					continue;
				String[] line = lines[i].split("\t", 20);
				String id = (line[1]);
				uniprotIDs.add(id);

			}

		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return uniprotIDs;

	}

	public static ArrayList<String> convertEnsembleProteinIDToPDBId(
			String ensembleId) {
		ArrayList<String> pdbIds = new ArrayList<String>();
		String t = convertEnsembleProteinToUniprot(ensembleId);

		// for (int i = 0; i < t.size(); ++i) {
		pdbIds.addAll(convertUniprotIdToPDBID(t));
		// }

		return pdbIds;

	}

	public static String fetchUniprotXML(String uniprotID) {
		String querl = UNIPROT_SERVER + "uniprot/" + uniprotID + ".xml";
		String result = REST.getResultLoop(querl);

		return result;

	}

	public static ArrayList<Pair<Integer, String>> getPTMsUingUniprot(
			String uniprotID) {
		String xml = fetchUniprotXML(uniprotID);

		return getPTMsUingUniprotXML(xml);

	}

	public static String getSequenceUniprot(String uniprotID) {
		String fasta = fetchUniprotFasta(uniprotID);

		return passFaste(fasta);

	}

	private static String fetchUniprotFasta(String uniprotID) {
		// TODO Auto-generated method stub
		String querl = UNIPROT_SERVER + "uniprot/" + uniprotID + ".fasta";
		String result = REST.getResultLoop(querl);

		return result;
	}

	private static String passFaste(String fasta) {
		// TODO Auto-generated method stub
		String sequence = "";

		String[] lines = fasta.split("\\n");
		for (int i = 0; i < lines.length; ++i) {
			if (lines[i].startsWith(">"))
				continue;

			sequence += lines[i];

		}

		return sequence;

	}

	public static ArrayList<Pair<Integer, String>> getPTMsUingUniprotXML(
			String xml) {
		ArrayList<Pair<Integer, String>> ptms = new ArrayList<Pair<Integer, String>>();

		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		DocumentBuilder db;
		String result = "";
		try {
			db = dbf.newDocumentBuilder();

			Document doc = db.parse(new InputSource(new ByteArrayInputStream(
					xml.getBytes("utf-8"))));
			// System.out.println(x);
			// MDebug.output(xml);

			NodeList rootList;

			doc.getDocumentElement().normalize();
			rootList = doc.getElementsByTagName("entry");
			Node tmpNode = rootList.item(0);
			Element e = (Element) tmpNode;
			if (e.getAttribute("dataset").equals("TrEMBL")) {
				return ptms;
			}

			rootList = doc.getElementsByTagName("feature");
			for (int i = 0; i < rootList.getLength(); ++i) {
				tmpNode = rootList.item(i);
				e = (Element) tmpNode;

				String featureType = e.getAttribute("type");
				if (featureType.contains("modified residue")
						|| featureType.contains("glycosylation site")) {
					String discription = e.getAttribute("description");

					NodeList t = e.getElementsByTagName("position");
					Element t1 = (Element) t.item(0);
					t1.getAttribute("position");

					// Node t2=t.item(1);

					// Element te = (Element) (e.getFirstChild());
					String pos = t1.getAttribute("position");
					int position = Integer.parseInt(pos);

					ptms.add(new Pair<Integer, String>(position, discription));

				}

			}

		} catch (SAXException e) {
			System.out.println(e.getMessage());
		} catch (ParserConfigurationException e) {
			System.out.println(e.getMessage());
		} catch (IOException e) {
			System.out.println(e.getMessage());
		}

		return ptms;
	}

	private static class ParameterNameValue {
		private final String name;
		private final String value;

		public ParameterNameValue(String name, String value)
				throws UnsupportedEncodingException {
			this.name = URLEncoder.encode(name, "UTF-8");
			this.value = URLEncoder.encode(value, "UTF-8");
		}
	}

	public static ArrayList<Quar<Integer, Integer, String, String>> getPfam(
			String tuniprot) {
		String querl = UNIPROT_SERVER + "uniprot/" + tuniprot + ".xml";
		String xml = REST.getResultLoop(querl);

		return passXML(xml);

	}

	private static ArrayList<Quar<Integer, Integer, String, String>> passXML(
			String xml) {

		ArrayList<Quar<Integer, Integer, String, String>> pfams = new ArrayList<Quar<Integer, Integer, String, String>>();

		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		DocumentBuilder db;
		String result = "";
		try {
			db = dbf.newDocumentBuilder();

			Document doc = db.parse(new InputSource(new ByteArrayInputStream(
					xml.getBytes("utf-8"))));
			// System.out.println(x);
			// MDebug.output(xml);

			NodeList rootList;

			doc.getDocumentElement().normalize();
			rootList = doc.getElementsByTagName("feature");
			for (int i = 0; i < rootList.getLength(); ++i) {
				Node tmpNode = rootList.item(i);
				Element e = (Element) tmpNode;
				String featureType = e.getAttribute("type");
				if (featureType.contains("transmembrane region")) {
					String discription = e.getAttribute("description");

					NodeList t = e.getElementsByTagName("begin");
					Element t1 = (Element) t.item(0);
					String beg = t1.getAttribute("position");

					t = e.getElementsByTagName("end");
					Element t2 = (Element) t.item(0);
					String end = t2.getAttribute("position");

					// Node t2=t.item(1);

					// Element te = (Element) (e.getFirstChild());
					// String pos = t1.getAttribute("position");
					// int position = Integer.parseInt(pos);
					int begPos = Integer.parseInt(beg);
					int endPos = Integer.parseInt(end);

					pfams.add(new Quar<Integer, Integer, String, String>(
							begPos, endPos, "transmembrane region", discription));

				}

			}

		} catch (SAXException e) {
			System.out.println(e.getMessage());
		} catch (ParserConfigurationException e) {
			System.out.println(e.getMessage());
		} catch (IOException e) {
			System.out.println(e.getMessage());
		}

		return pfams;
	}

	public static void main(String[] args) throws Exception {
		// String t = convertEnsembleProteinToUniprot("ENSP00000391478");
		// ArrayList<String> t2 = convertUniprotIdToPDBID("P04637");

		// ArrayList<String>
		// t=convertUcscGeneIDToUniprotIDs("uc007aeu.1");//P68510
		ArrayList<Pair<Integer, String>> s = getPTMsUingUniprot("P68510");

		// String s=getSequenceUniprot("E9PMR3");
		// System.out.println(s);
		for (Pair<Integer, String> a : s) {
			System.out.println(a.getValue1());

		}

		// System.out.println(t.get(0).getValue1());
		// System.out.println(t.get(0).getValue2());

		// System.out.println(t2.get(0));

	}

	public static ArrayList<String> convertUcscGeneIDToUniprotIDs(
			String unscGeneId) {
		// TODO Auto-generated method stub
		ArrayList<String> uniprotIDs = new ArrayList<String>();

		try {
			String result = run("mapping", new ParameterNameValue[] {
					new ParameterNameValue("from", "UCSC_ID"),
					new ParameterNameValue("to", "ACC"),
					new ParameterNameValue("format", "tab"),
					new ParameterNameValue("query", unscGeneId), });

			String[] lines = result.split("\n", 20);
			for (int i = 0; i < lines.length; ++i) {
				if (i == 0)
					continue;
				if (lines[i].length() < 1)
					continue;
				String[] line = lines[i].split("\t", 20);
				String id = (line[1]);
				uniprotIDs.add(id);

			}

		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return uniprotIDs;

	}

	public static ArrayList<String> convertEnsembleTransIDToUniprotIDs(
			String ensemblGeneID) {
		// TODO Auto-generated method stub
		ArrayList<String> uniprotIDs = new ArrayList<String>();

		try {
			String result = run("mapping", new ParameterNameValue[] {
					new ParameterNameValue("from", "ENSEMBL_TRS_ID"),
					new ParameterNameValue("to", "ACC"),
					new ParameterNameValue("format", "tab"),
					new ParameterNameValue("query", ensemblGeneID), });

			String[] lines = result.split("\n", 20);
			for (int i = 0; i < lines.length; ++i) {
				if (i == 0)
					continue;
				if (lines[i].length() < 1)
					continue;
				String[] line = lines[i].split("\t", 20);
				String id = (line[1]);
				uniprotIDs.add(id);

			}

		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return uniprotIDs;

	}

}ASTYPE.java/    1404006139  1000  1000  100600  88        `
package Utility.Structuure;

public enum ASTYPE {
	SE, A5SS, A3SS, RI, UNKNOWN

}
/398            1404006139  1000  1000  100600  1427      `
package Utility.Structuure;

/*
 * 
 */
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;

import java.io.InputStreamReader;

import java.nio.charset.Charset;

import java.util.HashMap;

public class ConfigureASEvent {
	public ConfigureASEvent() {
		super();
	}

	static public HashMap<String, String> configurietion = new HashMap<String, String>();

	public static HashMap<String, String> getConfigure() {
		return configurietion;
	}

	public static void readConfigureFromFile(String fileName) {
		// String fileName="Configure.txt";
		InputStream fis;
		BufferedReader br;
		String line;

		try {
			fis = new FileInputStream(fileName);
			br = new BufferedReader(new InputStreamReader(fis,
					Charset.forName("UTF-8")));

			while ((line = br.readLine()) != null) {
				if (line.startsWith("#"))
					continue;
				if (line.length() == 0)
					continue;
				String[] pair = line.split("\\t");
				configurietion.put(pair[0], pair[1]);

			}

		} catch (FileNotFoundException e) {
			System.out.println(e.getMessage());
		} catch (IOException e) {
			System.out.println(e.getMessage());
		}

	}

	public static void main(String[] args) {
		readConfigureFromFile("F:\\AS-pipeline\\ASproject\\Configure.txt");
		configurietion.get("UseVSL2Server");
	}

}

/421            1404006139  1000  1000  100600  1717      `
package Utility.Structuure;

import java.util.HashMap;

public class AminoAcidMap {
	public AminoAcidMap() {
		super();

	}

	static boolean init = false;
	static HashMap<String, String> aaTable = new HashMap<String, String>();

	static public String getAminoAcid(String aa) {
		if (!init) {
			aaTable.put("PHE", "F");
			aaTable.put("LEU", "L");
			aaTable.put("ILE", "I");
			aaTable.put("MET", "M");
			aaTable.put("VAL", "V");
			aaTable.put("SER", "S");
			aaTable.put("PRO", "P");
			aaTable.put("THR", "T");
			aaTable.put("ALA", "A");
			aaTable.put("TYR", "Y");
			aaTable.put("*", "*");
			aaTable.put("HIS", "H");
			aaTable.put("GLN", "Q");
			aaTable.put("ASN", "N");
			aaTable.put("LYS", "K");
			aaTable.put("ASP", "D");
			aaTable.put("GLU", "E");
			aaTable.put("CYS", "C");
			aaTable.put("ARG", "R");
			aaTable.put("SER", "S");
			aaTable.put("GLY", "G");

			init = true;
		}

		return aaTable.get(aa);
	}

	static public boolean haveAminoAcid(String aa) {
		if (!init) {
			aaTable.put("PHE", "F");
			aaTable.put("LEU", "L");
			aaTable.put("ILE", "I");
			aaTable.put("MET", "M");
			aaTable.put("VAL", "V");
			aaTable.put("SER", "S");
			aaTable.put("PRO", "P");
			aaTable.put("THR", "T");
			aaTable.put("ALA", "A");
			aaTable.put("TYR", "Y");
			aaTable.put("*", "*");
			aaTable.put("HIS", "H");
			aaTable.put("GLN", "Q");
			aaTable.put("ASN", "N");
			aaTable.put("LYS", "K");
			aaTable.put("ASP", "D");
			aaTable.put("GLU", "E");
			aaTable.put("CYS", "C");
			aaTable.put("ARG", "R");
			aaTable.put("SER", "S");
			aaTable.put("GLY", "G");

			init = true;
		}

		return aaTable.containsKey(aa);
	}

}

ColorTable.java/1404006139  1000  1000  100600  2350      `
package Utility.Structuure;

import java.awt.Color;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public class ColorTable {
	public ColorTable() {

		super();
	}

	private static HashMap<String, Color> mcolorTable = new HashMap<String, Color>();

	public static void buildColorTable() {
		if (mcolorTable.size() != 0)
			return;

		// mcolorTable.put("Snow", new Color(255, 250, 250));
		mcolorTable.put("Gainsboro", new Color(220, 220, 220));
		mcolorTable.put("Moccasin", new Color(255, 228, 181));
		mcolorTable.put("MediumSlateBlue", new Color(123, 104, 238));
		mcolorTable.put("SteelBlue", new Color(70, 130, 180));
		mcolorTable.put("DarkSlateGray2", new Color(141, 238, 238));
		mcolorTable.put("SeaGreen3", new Color(67, 205, 128));
		mcolorTable.put("Green2", new Color(0, 238, 0));
		mcolorTable.put("OliveDrab1", new Color(192, 255, 62));
		mcolorTable.put("OliveDrab4", new Color(105, 139, 34));
		mcolorTable.put("Yellow1", new Color(255, 255, 0));
		mcolorTable.put("Yellow4", new Color(139, 139, 0));
		mcolorTable.put("RosyBrown", new Color(188, 143, 143));
		// mcolorTable.put("Beige", new Color(245, 245, 220));
		mcolorTable.put("SandyBrown", new Color(244, 164, 96));
		mcolorTable.put("OrageRed", new Color(255, 69, 0));
		mcolorTable.put("Tan1", new Color(255, 165, 79));
		mcolorTable.put("Pink", new Color(255, 192, 203));
		mcolorTable.put("Violet", new Color(238, 130, 238));
		// mcolorTable.put("Bisque1", new Color(255, 228, 196));
		mcolorTable.put("RosyBrown", new Color(188, 143, 143));

	}

	public static Color getRandomColor() {
		if (mcolorTable.size() == 0)
			return new Color(255, 255, 0);

		int n = (int) (Math.random() * (mcolorTable.size() - 1));
		Iterator<Map.Entry<String, Color>> ite = mcolorTable.entrySet()
				.iterator();
		int i = 0;
		Color result = new Color(255, 255, 0);
		while (ite.hasNext()) {
			ite.next();
			if (i == n) {
				@SuppressWarnings("rawtypes")
				Map.Entry entry = (Map.Entry) ite.next();
				result = (Color) entry.getValue();
				break;
			}
			i++;
		}

		return result;

	}

	public static Color getAColor(String name) {
		return mcolorTable.get(name);

	}

	public static void main(String[] args) {
		buildColorTable();
		ColorTable.getRandomColor();

	}

}
/440            1392211467  1000  1000  100600  31        `
package Utility.Structuure;


Tris.java/      1404006139  1000  1000  100600  635       `
package Utility.Structuure;

public class Tris<T1, T2, T3> {
	public Tris() {
		super();
	}

	public Tris(T1 t1, T2 t2, T3 t3) {
		value1 = t1;
		value2 = t2;
		value3 = t3;
	}

	T1 value1;
	T2 value2;
	T3 value3;

	public String toString() {
		return value1 + "\t" + value2 + "\t" + value3;
	}

	public T1 getValue1() {
		return value1;
	}

	public T2 getValue2() {
		return value2;
	}

	public T3 getValue3() {
		return value3;
	}

	public void setValue1(T1 t1) {
		value1 = t1;
	}

	public void setValue2(T2 t2) {
		value2 = t2;
	}

	public void setValue3(T3 t3) {
		value3 = t3;
	}

}

Pair.java/      1404006139  1000  1000  100600  448       `
package Utility.Structuure;

public class Pair<T1, T2> {
	public Pair(T1 v1, T2 v2) {
		this.value1 = v1;
		this.value2 = v2;
	}

	T1 value1;
	T2 value2;

	public String toString() {

		return value1 + "\t" + value2;
	}

	public T1 getValue1() {
		return value1;
	}

	public T2 getValue2() {
		return value2;
	}

	public void setValue1(T1 v1) {
		value1 = v1;
	}

	public void setValue2(T2 v2) {
		value2 = v2;
	}

}Quar.java/      1404006139  1000  1000  100664  674       `
package Utility.Structuure;

public class Quar<T1, T2, T3, T4> {
	public Quar(T1 t1, T2 t2, T3 t3, T4 t4) {
		value1 = t1;
		value2 = t2;
		value3 = t3;
		value4 = t4;

	}

	public Quar() {

	}

	T1 value1;
	T2 value2;
	T3 value3;
	T4 value4;

	public T1 getValue1() {
		return value1;
	}

	public T2 getValue2() {
		return value2;
	}

	public T3 getValue3() {
		return value3;
	}

	public T4 getValue4() {
		return value4;
	}

	public void setValue1(T1 tvalue1) {
		value1 = tvalue1;
	}

	public void setValue2(T2 tvalue2) {
		value2 = tvalue2;
	}

	public void setValue3(T3 tvalue3) {
		value3 = tvalue3;
	}

	public void setValue4(T4 tvalue4) {
		value4 = tvalue4;
	}

}
DISTYPE.java/   1404006139  1000  1000  100664  103       `
package Utility.Structuure;

public enum DISTYPE {
	NODISORDER, PARTDISORDER, FULLDISORDER, UNKNOWN

}

/459            1392211505  1000  1000  100600  30        `
package Utility.Algorithm;

/478            1404006139  1000  1000  100600  893       `
package Utility.Algorithm;

import org.biojava3.core.sequence.transcription.Frame;

public class FrameConvertToInt {
	public FrameConvertToInt() {
		super();
	}

	static public int convertFrameToInt(Frame frame) {
		if (frame.equals(Frame.ONE))
			return 1;
		if (frame.equals(Frame.TWO))
			return 2;
		if (frame.equals(Frame.THREE))
			return 3;

		if (frame.equals(Frame.REVERSED_ONE))
			return 1;
		if (frame.equals(Frame.REVERSED_TWO))
			return 2;
		if (frame.equals(Frame.REVERSED_THREE))
			return 3;

		return -1;
	}

	public static Frame convertintToFrame(int t) {
		if (t == 0)
			return Frame.ONE;
		if (t == 1)
			return Frame.TWO;
		if (t == 2)
			return Frame.THREE;

		if (t == 3)
			return Frame.REVERSED_ONE;
		if (t == 4)
			return Frame.REVERSED_TWO;
		if (t == 5)
			return Frame.REVERSED_THREE;

		return Frame.ONE;

	}

}

REST.java/      1404006139  1000  1000  100600  2091      `
package Utility.Algorithm;

/*
 * REST service.
 */
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.HttpURLConnection;

import Utility.ASDebug;

public class REST {

	public static void main(String[] args) {

		String serverString = "http://genome.ucsc.edu/cgi-bin/das/";
		String qstr = serverString + "ce6/dna?segment=chrII:1,100000";

		try {

			String s = REST.getResultLoop(qstr);

			ASDebug.output(s);

		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	public static String getResultOnce(String qstr) throws IOException,
			InterruptedException {
		String urlStr = qstr;
		String result = "";

		URL url;

		url = new URL(urlStr);

		HttpURLConnection conn = (HttpURLConnection) url.openConnection();
		conn.setReadTimeout(1000000);
		// conn.
		int i = 0;
		while (conn.getResponseCode() != 200) {

			Thread.sleep(1000);

			// ASDebug.output(conn.getResponseCode());
			// ASDebug.output(conn.getResponseMessage());
			conn.disconnect();
			conn = (HttpURLConnection) url.openConnection();

			// ASDebug.output(i);
			if (i > 500)
				break;
			i++;
		}

		if (conn.getResponseCode() != 200) {
			throw new IOException(conn.getResponseMessage());
		}

		// Buffer the result into a string
		BufferedReader rd = new BufferedReader(new InputStreamReader(
				conn.getInputStream()));
		StringBuilder sb = new StringBuilder();
		String line;
		while ((line = rd.readLine()) != null) {
			sb.append(line + "\n");
			// ASDebug.output(line);
		}
		rd.close();

		conn.disconnect();
		result = sb.toString();

		return result;
	}

	public static String getResultLoop(String qstr) {
		String result = "";

		boolean runSuccessfull = false;
		while (!runSuccessfull) {

			try {
				runSuccessfull = true;

				result = getResultOnce(qstr);

			} catch (Exception e) {
				System.out.println(e.getMessage());
				runSuccessfull = false;

			}
		}
		return result;
	}
}

RESTPDB.java/   1404006139  1000  1000  100600  11274     `
package Utility.Algorithm;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

import Utility.ASDebug;
import Utility.Structuure.AminoAcidMap;

public class RESTPDB {
	public RESTPDB() {
		super();
	}

	public static final String SERVICELOCATION = "http://www.rcsb.org/pdb/rest/search";

	public static final String serviceDes = "http://www.rcsb.org/pdb/rest/describePDB?structureId=";
	public static final String entityDes = "http://www.rcsb.org/pdb/rest/describeMol?structureId=";

	public static HashMap<String, String> idFiles = new HashMap<String, String>();

	public static String getDescription(String pdbId) {
		String result = "";

		String searchString = serviceDes + pdbId;
		try {
			URL url;

			url = new URL(searchString);

			HttpURLConnection conn = (HttpURLConnection) url.openConnection();
			conn.setReadTimeout(10000);
			// conn.
			int i = 0;
			while (conn.getResponseCode() != 200) {

				Thread.sleep(1000);

				System.out.println(conn.getResponseCode());
				System.out.println(conn.getResponseMessage());
				conn.disconnect();
				conn = (HttpURLConnection) url.openConnection();

				System.out.println(i);
				if (i > 10)
					continue;
				i++;
			}

			if (conn.getResponseCode() != 200) {
				throw new IOException(conn.getResponseMessage());
			}

			// Buffer the result into a string
			BufferedReader rd = new BufferedReader(new InputStreamReader(
					conn.getInputStream()));
			StringBuilder sb = new StringBuilder();
			String line;
			while ((line = rd.readLine()) != null) {
				sb.append(line);
				ASDebug.output(line);
			}
			rd.close();

			conn.disconnect();

			result = sb.toString();
			int start = result.indexOf("title");
			int end = result.indexOf("pubmedId");
			result = pdbId + "\t" + result.substring(start, end);

		} catch (MalformedURLException e) {
			System.out.println(e.getMessage());
		} catch (InterruptedException e) {
			System.out.println("interrupt error");
		} catch (IOException e) {
			System.out.println(e.getMessage());
		}

		return result;
	}

	public static String getEntityDescription(String pdbId) {
		String result = "";

		String searchString = entityDes + pdbId;
		try {
			URL url;

			url = new URL(searchString);

			HttpURLConnection conn = (HttpURLConnection) url.openConnection();
			conn.setReadTimeout(10000);
			// conn.
			int i = 0;
			while (conn.getResponseCode() != 200) {

				Thread.sleep(1000);

				ASDebug.output(conn.getResponseCode());
				ASDebug.output(conn.getResponseMessage());
				conn.disconnect();
				conn = (HttpURLConnection) url.openConnection();

				ASDebug.output(i);
				if (i > 10)
					continue;
				i++;
			}

			if (conn.getResponseCode() != 200) {
				throw new IOException(conn.getResponseMessage());
			}

			// Buffer the result into a string
			BufferedReader rd = new BufferedReader(new InputStreamReader(
					conn.getInputStream()));
			StringBuilder sb = new StringBuilder();
			String line;
			while ((line = rd.readLine()) != null) {
				sb.append(line);
				// System.out.println(line);
			}
			rd.close();

			conn.disconnect();

			result = sb.toString();
			int start = result.indexOf("Taxonomy name=");
			// int end=result.indexOf("pubmedId");
			int end = start + 200;
			result = result.substring(start, end);

			result = result.substring(15, result.indexOf("id") - 2);

			ASDebug.output(result);

			// result=pdbId+"\t"+result.substring(start, end);

		} catch (MalformedURLException e) {
			System.out.println(e.getMessage());
		} catch (InterruptedException e) {
			System.out.println("interrupt error");
		} catch (IOException e) {
			System.out.println(e.getMessage());
		}

		return result;
	}

	public static ArrayList<String> getDescription(List<String> pdbIds) {
		ArrayList<String> result = new ArrayList<String>();
		Iterator<String> ids = pdbIds.iterator();
		while (ids.hasNext()) {
			result.add(getDescription(ids.next()));

		}
		return result;

	}

	/**
	 * do a POST to a URL and return the response stream for further processing
	 * elsewhere.
	 * 
	 * 
	 * @param url
	 * @return
	 * @throws IOException
	 */
	public static InputStream doPOST(URL url, String data) throws IOException {

		// Send data

		URLConnection conn = url.openConnection();

		conn.setDoOutput(true);

		OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());

		wr.write(data);
		wr.flush();

		// Get the response
		return conn.getInputStream();

	}

	/**
	 * post am XML query (PDB XML query format) to the RESTful RCSB web service
	 * 
	 * @param xml
	 * @return a list of PDB ids.
	 */
	public static ArrayList<String> postQuery(String xml) throws IOException {

		URL u = new URL(SERVICELOCATION);

		String encodedXML = URLEncoder.encode(xml, "UTF-8");

		InputStream in = doPOST(u, encodedXML);

		ArrayList<String> pdbIds = new ArrayList<String>();

		BufferedReader rd = new BufferedReader(new InputStreamReader(in));

		String line;
		while ((line = rd.readLine()) != null) {

			pdbIds.add(line);

		}
		rd.close();

		return pdbIds;

	}

	public static ArrayList<String> fetchPDBId(String nucliedSequence) {

		/*
		 * String xml = "<orgPdbCompositeQuery version=\"1.0\">" +
		 * 
		 * " <queryRefinement>" +
		 * 
		 * "  <queryRefinementLevel>0</queryRefinementLevel>" +
		 * 
		 * "  <orgPdbQuery>" +
		 * "    <queryType>org.pdb.query.simple.SequenceQuery</queryType>" +
		 * 
		 * "    <description><![CDATA[Sequence Search (Structure:Chain = 1HIV:A, Expectation Value = 10.0, Search Tool = blast)]]></description>"
		 * + "    <structureId><![CDATA[1HIV]]></structureId>" +
		 * "    <chainId><![CDATA[A]]></chainId>" +
		 * 
		 * "    <sequence><![CDATA["+proteinSeq+"]]></sequence>" +
		 * "    <eCutOff><![CDATA[10.0]]></eCutOff>" +
		 * "    <searchTool><![CDATA[blast]]></searchTool>" +
		 * 
		 * "  </orgPdbQuery>" +
		 * 
		 * " </queryRefinement>" + " <queryRefinement>" +
		 * 
		 * "  <queryRefinementLevel>1</queryRefinementLevel>" +
		 * "  <conjunctionType>and</conjunctionType>" +
		 * 
		 * "  <orgPdbQuery>" +
		 * 
		 * "    <queryType>org.pdb.query.simple.ExpTypeQuery</queryType>" +
		 * "    <description><![CDATA[Experimental Method Search : Experimental Method=X-RAY]]></description>"
		 * + "    <runtimeMilliseconds>1389</runtimeMilliseconds>" +
		 * 
		 * "    <mvStructure.expMethod.value><![CDATA[X-RAY]]></mvStructure.expMethod.value>"
		 * + "  </orgPdbQuery>" +
		 * 
		 * " </queryRefinement>" +
		 * 
		 * "</orgPdbCompositeQuery>";
		 */

		String xml = "<orgPdbQuery>\n"
				+ "\n"
				+ "<queryType>org.pdb.query.simple.BlastXQuery</queryType>\n"
				+ "\n"
				+ "<description>BLASTX Search (Sequence = ATGCCAGGGGCAGTGGAAGGCCCCAGGTGGAAGCAGGCAGAAGACATTA), Expectation Value = 10.0)</description>\n"
				+ "\n" + "<sequence>" + nucliedSequence + "</sequence>\n"
				+ "\n" + "<eCutOff>0.0001</eCutOff>\n" + "\n"
				+ "</orgPdbQuery>\n";

		// PostXMLQuery t = new PostXMLQuery();
		ArrayList<String> pdbIds = new ArrayList<String>();

		try {
			pdbIds = postQuery(xml);
			for (String string : pdbIds) {

				ASDebug.output(string);

			}

		} catch (Exception e) {
			e.printStackTrace();

		}
		return pdbIds;

	}

	public static String fetchPDBFile(String pdbId) {
		if (idFiles.containsKey(pdbId))
			return idFiles.get(pdbId);

		String domain = "http://www.rcsb.org/pdb/files/";
		String tail = ".pdb";
		String searchStr = domain + pdbId + tail;

		URL url;
		String pdb = new String("");
		try {
			url = new URL(searchStr);
			InputStream webIS = url.openStream();
			BufferedInputStream in = new BufferedInputStream(webIS);

			BufferedReader inBr = new BufferedReader(new InputStreamReader(in));
			String line = "";
			while ((line = inBr.readLine()) != null) {
				// c = webIS.read();
				// System.out.println("==============> "+c);
				// if(c!=-1) fo.write((byte)c);
				// if(c!=-1) pdb+=(byte)c;
				pdb += (line + "\n");
				// MDebug.output(line);
			}

		} catch (MalformedURLException e) {
			System.out.println(e.getMessage());
		} catch (IOException e) {
			System.out.println(e.getMessage());

		} // image on server

		if (!idFiles.containsKey(pdbId))
			idFiles.put(pdbId, pdb);

		return pdb;
	}

	public static String fecthPDBSeq(String tpdbFile) {
		String aminoAcid = "";
		String[] lines = tpdbFile.split("\n");

		for (int i = 0; i < lines.length; ++i) {
			if (lines[i].startsWith("SEQRES")) {
				String line = lines[i].substring(19);
				String[] aminos = line.split(" ", 20);
				for (int j = 0; j < aminos.length; ++j) {
					if (aminos[j].length() < 3)
						continue;
					String aa = aminos[j];
					if (AminoAcidMap.haveAminoAcid(aa)) {
						aminoAcid += AminoAcidMap.getAminoAcid(aa);
					}
				}

			}

		}

		return aminoAcid;
	}

	public static ArrayList<String> fetchPDBFiles(List<String> pdbIds) {
		ArrayList<String> pdbFiles = new ArrayList<String>();

		Iterator<String> ite = pdbIds.iterator();
		while (ite.hasNext()) {
			pdbFiles.add(fetchPDBFile(ite.next()));

		}

		return pdbFiles;
	}

	public static ArrayList<String> fetchPDBFiles(String nucliedSequence) {
		return fetchPDBFiles(fetchPDBId(nucliedSequence));

	}

	// this function below doesn't work
	@SuppressWarnings("resource")
	public static String readParsePDBFile(String fileName) {
		String str = "";

		File file = new File(fileName);
		BufferedReader input;
		try {
			input = new BufferedReader(new FileReader(file));

			String text;

			while ((text = input.readLine()) != null)
				str += text + "\\n";

		} catch (FileNotFoundException e) {
			System.out.println(e.getMessage());
		} catch (IOException e) {
			System.out.println(e.getMessage());
		}

		return str;
	}

	public static void main(String[] args) {
		List<String> a = fetchPDBId("ACTCTTCTGTTTAGCCACATTTGCGTAAGTATTTTCAATTTCTTTGTCTTCAGGACACGTGTGGGTAAATTCTTCACGGGCATAGGCATTGTGGAGATAACGCCAGACTCCTGAGAATTCTGCTGGAATGTCAAAGTCACGATATTTCTTGGCAGCAACTTTAATAATGTTCAGCTTGGGTAACAAGCTACAATCAGCCAGTGTTAGCTGGTCCCCATCCAAGAATAGTCTTCTGGAAACTGGGGGTTCCTCAGCACTGTCTGGATCAATTTCATCCAGAAGTGGGGTGTTTAAGTAGTCATCCAGACGCTTGAATTCTTTGAGCAGAGATTTTTCAAAATTCTTATTTGCCTCCTTTTGTGTATTCTTAATGTATGCAGAAAACTTGGCAAAGAGGTTACAGCCCACATCAAAAGACTCCTTGTACTTGGGACTCAGGTGAGGGTACCTTGGAGGAGCCAGGGTTTGTTCTAAAAACTCCTCAATTTTAATGAAGTCTGTTTTCAACTCCTTGTTATACACCAGGAACGGAGGATTGGTACCTGGGGCTAAGTCCTTTAGTTCTTCAGGCTTTCTGGTCATGTCAACAGTTGTCACATTAAATTTAACTCCTTTAAGCCAGAGGATCATGAAAAGGCGTTGGCAAAAGGGACAGTTTCCAATACTCTCTCCATCACTTCCAGCCTTTACAAAAAGCTCAATCTCAGGGTCCACTTGAGTGCCGGGCCGCAGGCCTGACAT");
		// System.out.println(fecthPDBSeq(a.get(0)));
		// fetchPDBFile("3KZ4");

		// System.out.println(getDescription("1CLM"));
		Iterator<String> ite = a.iterator();
		while (ite.hasNext()) {
			System.out.println(ite.next());
		}
		// System.out.println(readParsePDBFile("F:\\AS-pipeline\\ASproject\\ASHtmlpageNotServer\\1CLM.pdb\\pdb1clm.ent"));

	}

}
/502            1404006138  1000  1000  100600  5055      `
package Utility.Algorithm;

import org.biojava3.alignment.Alignments;
import org.biojava3.alignment.SimpleGapPenalty;
import org.biojava3.alignment.SimpleSubstitutionMatrix;
import org.biojava3.alignment.template.SequencePair;
import org.biojava3.alignment.template.SubstitutionMatrix;
import org.biojava3.core.sequence.ProteinSequence;
import org.biojava3.core.sequence.compound.AminoAcidCompound;
import org.biojava3.alignment.Alignments.PairwiseSequenceAlignerType;

import Utility.ASDebug;
import Utility.Structuure.Tris;

public class ProteinAlign {
	public ProteinAlign() {
		super();
	}

	public static String alignProteins(String templete, String alignProtein) {

		return align(templete, alignProtein).toString();

	}

	public static SequencePair<ProteinSequence, AminoAcidCompound> align(
			String protein1, String protein2) {
		ProteinSequence s1 = new ProteinSequence(protein1), s2 = new ProteinSequence(
				protein2);
		SubstitutionMatrix<AminoAcidCompound> matrix = new SimpleSubstitutionMatrix<AminoAcidCompound>();
		SequencePair<ProteinSequence, AminoAcidCompound> pair = Alignments
				.getPairwiseAlignment(s1, s2,
						PairwiseSequenceAlignerType.GLOBAL,
						new SimpleGapPenalty(), matrix);
		// pair.get
		System.out.printf("%n%s vs %s%n%s", pair.getQuery().getAccession(),
				pair.getTarget().getAccession(), pair);
		// pair.
		return pair;
	}

	public static Tris<String, Integer, Integer> getASSite(String protein1,
			String protein2) {
		SequencePair<ProteinSequence, AminoAcidCompound> pair = align(protein1,
				protein2);
		String searchStr = pair.toString().split("\n")[0].trim();
		int begPos = protein1.indexOf(searchStr);
		int endPos = begPos + searchStr.length();
		System.out.println("proteinAlign");
		System.out.println(protein1);
		System.out.println(searchStr);

		return new Tris<String, Integer, Integer>(pair.toString(), begPos,
				endPos);

	}

	/*
	 * public static int getSNPPosition(String proteinSequence, String
	 * pdbProtein, int tsnpPos) { // TODO Auto-generated method stub
	 * SequencePair<ProteinSequence, AminoAcidCompound>
	 * pair=align(proteinSequence,pdbProtein); String
	 * searchStr=pair.toString().split("\n")[1].trim(); int
	 * pos=pdbProtein.indexOf(searchStr); //pdbProtein[tsnpPos];
	 * if(tsnpPos+pos<pdbProtein.length()) return pos+tsnpPos; else return -1; }
	 */

	public static int getSNPPosition(String proteinSequence, String pdbProtein,
			int pos) {
		// TODO Auto-generated method stub
		int index = 0;
		String alignStatus;

		// if(protein.length()>pdbProtein.length())
		// alignStatus=ProteinAlign.alignProteins(pdbProtein, protein);

		// else
		// alignStatus=ProteinAlign.alignProteins(protein,pdbProtein);
		alignStatus = ProteinAlign.alignProteins(pdbProtein, proteinSequence);
		System.out.println(alignStatus);// .output(alignStatus);
		System.out.println("snp in transcript=" + pos);

		String align2[] = alignStatus.split("\n");

		ASDebug.output("pos=" + pos);

		int snpPosInAlign = pos;
		for (int i = 0; i < snpPosInAlign; ++i) {
			if (align2[1].charAt(i) == '-')
				snpPosInAlign++;

		}

		if (align2[0].charAt(snpPosInAlign) == '-'
				|| align2[1].charAt(snpPosInAlign) == '-') {
			// proteinHaveSNP=false;
			return -1;
		}

		int pdbShift = 0;

		for (int i = 0; i < snpPosInAlign; ++i) {
			if (align2[0].charAt(i) == '-')
				pdbShift++;
		}

		int snpPdbPos = snpPosInAlign - pdbShift;

		System.out.println("snp position in pdb=" + snpPdbPos);
		// if(align2[0].charAt(snpPdbPos)=='-')
		// return -1;
		if (snpPdbPos == 0)
			return -1;

		return snpPdbPos;

	}

	public static void main(String[] args) {
		// SequencePair<ProteinSequence, AminoAcidCompound>
		// pair=align("REGVRFAQSPAGEEARGDQSEKYMEFDLNNEGEIDLMSLKRMMEKLGVPKTHLEMKKMISEVTGGVSDTISYRDFVNMMLGKRSAVLKL","EKLGVPKTHLEMKKAAAMISEVTGGV"
		// );

		String proteinSequence = "NSKKKTKKLRMKRSHRVEPVNTDESTPKSPTPPQPPPPVGWGTPKVTRLPKLEPLGETRHNDFYGKPLPPLAVRQRPNGDAQDTIS";
		String uniprotSequence = "MFSLMANCCNLFKRWREPVRKVTLVMVGLDNAGKTATAKGIQGEHPEDVAPTVGFSKIDLRQGKFQVTIFDLGGGKRIRGIWKNYYAESYGVIFVVDSSDEERMEETKETMSEVLRHPRISGKPILVLANKQDKEGALGEADVIECLSLEKLVNEHKCLCQIEPCSAVLGYGKKIDKSIKKGLYWLLHIIAKDFDALSERIQKDTTEQRALEEQEKRERAERVRKLREEREREQTELDGTSGLAEIDSGPVLANPFQPIAAVIIENEKKQEKEKKKQTVEKDSDVGLLEHKVEPEQAAPQSEADCCLQNPDERVVDSYREALSQQLDSEDEQDQRGSESGENSKKKTKKLRMKRSHRVEPVNTDESTPKSPTPPQPPPPVGWGTPKVTRLPKLEPLGETRHNDFYGKPLPPLAVRQRPNGDAQDTIS";
		System.out
				.println(getSNPPosition(uniprotSequence, proteinSequence, 342));

		// System.out.println(pair.toString());
		// String
		// str="AEQLTEEQIAEFKEAFALFDKDGDGTITTKELGTVMRSLGQNPTEAELQDMINEVDADGNGTIDFPEFLSLMARKMKEQDSEEELIEAFKVFDRDGNGLISAAELRHVMTNLGEKLTDDEVDEMIREADIDGDGHINYEEFVRMMVSKAEQLTEEQIAEFKEAFALFDKDGDGTITTKELGTVMRSLGQNPTEAELQDMINEVDADGNGTIDFPEFLSLMARKMKEQDSEEELIEAFKVFDRDGNGLISAAELRHVMTNLGEKLTDDEVDEMIREADIDGDGHINYEEFVRMMVSK";
		// System.out.println(str.indexOf("EEQIAEFKEAFALFDKDGDGTITTKELGTVMRSLGQNPTEAELQDMINEVDADGNGTIDFPEFLSLMARK"));

		// REGVRFAQSPAGEEARGDQSEKYMEFDLNNEGEIDLMSLKRMMEKLGVPKTHLEMKKMISEVTGGVSDTISYRDFVNMMLGKRSAVLKL
	}

}
ASRandom.java/  1404006139  1000  1000  100600  849       `
package Utility.Algorithm;

import java.util.Random;

public class ASRandom {
	private static char[] numbersAndLetters;

	public ASRandom() {
		super();
	}

	private static Random randGen = null;

	public static String randomCharGenerator(int length) {

		if (length < 1) {
			return null;
		}
		if (randGen == null) {
			randGen = new Random();
			numbersAndLetters = ("0123456789abcdefghijklmnopqrstuvwxyz"
					+ "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ").toCharArray();
			// numbersAndLetters =
			// ("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ").toCharArray();
		}
		char[] randBuffer = new char[length];
		for (int i = 0; i < randBuffer.length; i++) {
			randBuffer[i] = numbersAndLetters[randGen.nextInt(71)];
			// randBuffer[i] = numbersAndLetters[randGen.nextInt(35)];
		}
		return new String(randBuffer);
	}

}

Translate.java/ 1404628475  1000  1000  100664  4115      `
package Utility.Algorithm;

import java.util.HashMap;

public class Translate {
	public Translate() {
		super();
	}

	static HashMap<String, String> transLateMapOneWord = new HashMap<String, String>();

	static HashMap<String, String> transLateMapThreeWord = new HashMap<String, String>();

	static void init() {

		initTranslate();

	}

	static void initTranslate() {
		transLateMapOneWord.put("TTT", "F");
		transLateMapOneWord.put("TTC", "F");
		transLateMapOneWord.put("TTA", "L");
		transLateMapOneWord.put("TTG", "L");

		transLateMapOneWord.put("CTT", "L");
		transLateMapOneWord.put("CTC", "L");
		transLateMapOneWord.put("CTA", "L");
		transLateMapOneWord.put("CTG", "L");

		transLateMapOneWord.put("ATT", "I");
		transLateMapOneWord.put("ATC", "I");
		transLateMapOneWord.put("ATA", "I");
		transLateMapOneWord.put("ATG", "M");

		transLateMapOneWord.put("GTT", "V");
		transLateMapOneWord.put("GTC", "V");
		transLateMapOneWord.put("GTA", "V");
		transLateMapOneWord.put("GTG", "V");

		transLateMapOneWord.put("TCT", "S");
		transLateMapOneWord.put("TCC", "S");
		transLateMapOneWord.put("TCA", "S");
		transLateMapOneWord.put("TCG", "S");

		transLateMapOneWord.put("CCT", "P");
		transLateMapOneWord.put("CCC", "P");
		transLateMapOneWord.put("CCA", "P");
		transLateMapOneWord.put("CCG", "P");

		transLateMapOneWord.put("ACT", "T");
		transLateMapOneWord.put("ACC", "T");
		transLateMapOneWord.put("ACA", "T");
		transLateMapOneWord.put("ACG", "T");

		transLateMapOneWord.put("GCT", "A");
		transLateMapOneWord.put("GCC", "A");
		transLateMapOneWord.put("GCA", "A");
		transLateMapOneWord.put("GCG", "A");

		transLateMapOneWord.put("TAT", "Y");
		transLateMapOneWord.put("TAC", "Y");
		transLateMapOneWord.put("TAA", "*");
		transLateMapOneWord.put("TAG", "*");

		transLateMapOneWord.put("CAT", "H");
		transLateMapOneWord.put("CAC", "H");
		transLateMapOneWord.put("CAA", "Q");
		transLateMapOneWord.put("CAG", "Q");

		transLateMapOneWord.put("AAT", "N");
		transLateMapOneWord.put("AAC", "N");
		transLateMapOneWord.put("AAA", "K");
		transLateMapOneWord.put("AAG", "K");

		transLateMapOneWord.put("GAT", "D");
		transLateMapOneWord.put("GAC", "D");
		transLateMapOneWord.put("GAA", "E");
		transLateMapOneWord.put("GAG", "E");

		transLateMapOneWord.put("TGT", "C");
		transLateMapOneWord.put("TGC", "C");
		transLateMapOneWord.put("TGA", "*");
		transLateMapOneWord.put("TGG", "W");

		transLateMapOneWord.put("CGT", "R");
		transLateMapOneWord.put("CGC", "R");
		transLateMapOneWord.put("CGA", "R");
		transLateMapOneWord.put("CGG", "R");

		transLateMapOneWord.put("AGT", "S");
		transLateMapOneWord.put("AGC", "S");
		transLateMapOneWord.put("AGA", "R");
		transLateMapOneWord.put("AGG", "R");

		transLateMapOneWord.put("GGT", "G");
		transLateMapOneWord.put("GGC", "G");
		transLateMapOneWord.put("GGA", "G");
		transLateMapOneWord.put("GGG", "G");
	}

	static char complement(char tc) {
		if (tc == 'A')
			return 'T';
		if (tc == 'C')
			return 'G';
		if (tc == 'G')
			return 'C';
		if (tc == 'T')
			return 'A';

		return '*';
	}

	static boolean isInit = false;

	static public String translate(String tnucliedSequence) {
		if (!isInit)
			init();
		tnucliedSequence = tnucliedSequence.toUpperCase();

		String result = "";

		for (int i = 0; i < tnucliedSequence.length() / 3; ++i) {
			String aa = "";
			aa += tnucliedSequence.charAt(i * 3);
			aa += tnucliedSequence.charAt(i * 3 + 1);
			aa += tnucliedSequence.charAt(i * 3 + 2);
			aa = aa.toUpperCase();
			result += transLateMapOneWord.get(aa);
			// System.out.println(transLateMapOneWord.get(aa)+"\t"+aa);

		}
		
		return result;
	}

	static public String getReverseCompliment(String tnucliedSeq) {
		String reverseString = "";
		tnucliedSeq = tnucliedSeq.toUpperCase();

		for (int i = tnucliedSeq.length() - 1; i > 0; --i) {
			reverseString += complement(tnucliedSeq.charAt(i));
		}

		return reverseString;
	}

	public static void main(String[] args) {
		String a = "ATGGCTGGCTACCTGAGTGAATCGGACTTTGTGATGGTGGAGGAGGGCTT";
		String t = translate(getReverseCompliment(a).substring(2));

		System.out.println(t);
	}

}

ASevent.java/   1404529913  1000  1000  100600  6020      `
package ASEvent;

import java.util.ArrayList;
import java.util.Iterator;

import GeneStructure.Exon;
import GeneStructure.Strand;
import Utility.ASDebug;
import Utility.SequenceFeatureWrapper.SequenceFeatureExtractor;
import Utility.Structuure.ASTYPE;
import Utility.Structuure.Tris;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

public abstract class ASevent {

	public ASevent(String toneEvent, String torganism) {
		oneEvent = toneEvent;
		organism = torganism;

		// init(toneEvent);

	}

	/*
	 * regex pattern for determining the alternative splicing type
	 * cassete,alternative 3' site or alternative 5' site or retained intro.
	 */

	public String id = "";

	protected ASTYPE asType = ASTYPE.UNKNOWN;

	protected Strand strand;

	protected String oneEvent;

	protected Fragment frag = new Fragment();

	protected String organism;

	protected String chr;

	protected ArrayList<EventIsoformFeature> eventIsoforms = new ArrayList<EventIsoformFeature>();
	
	protected ArrayList<Tris<String,Integer,Integer>> asRegions=new ArrayList<Tris<String,Integer,Integer>>();

	protected ArrayList<String> pfamInfo = new ArrayList<String>();

	protected ArrayList<String> cdss = new ArrayList<String>();
	
	protected ArrayList<Float> conservationScore=new ArrayList<Float>();

	public void init() {

		asType = tellASType(oneEvent);

		ASDebug.output(asType.toString());
		buildGeneFrag();
		ASDebug.output(frag.getSequence());
		asRegions=SequenceFeatureExtractor.getASRegions(chr, frag.getSeqBegPos(), frag.getSeqEndPos());
		conservationScore=SequenceFeatureExtractor.getConservationScore(chr, frag.getSeqBegPos(), frag.getSeqEndPos());
		
		
		// System.out.println(frag.getSeqBegPos() + "\t" + frag.getSeqEndPos());

		translate();

		// buildPfamInfo();//never used

		// buildCDSInfo();
	}

	protected abstract void buildGeneFrag();

	protected abstract ASTYPE tellASType(String toneEvent);

	protected abstract void translate();

	public Element processXML(Document doc, Element tableRoot) {
		Element eventNode = processXMLSequence(doc, tableRoot);

		for (int i = 0; i < eventIsoforms.size(); ++i) {
			eventIsoforms.get(i)
					.processXMLProtein(doc, tableRoot, eventNode, i);

		}
		return eventNode;
	}

	private Element processXMLSequence(Document doc, Element tableRoot) {
		Element eventRoot = doc.createElement("event");

		tableRoot.appendChild(eventRoot);
		// doc.appendChild(tableRoot);

		Element posNode = doc.createElement("position");
		posNode.setTextContent(oneEvent);
		eventRoot.appendChild(posNode);
		
		Element strandNode = doc.createElement("strand");
		strandNode.setTextContent(frag.strand.toString());
		eventRoot.appendChild(strandNode);
		
		
		// alternative splicing type
		Element exonsNode = doc.createElement("alternativeExons");
		Iterator<Exon> iteExon = frag.getExonsIterator();
		while (iteExon.hasNext()) {
			Exon exon = iteExon.next();
			Element exonNode = doc.createElement("exon");
			exonNode.setAttribute("start", "" + exon.getExonBegCoorPos());
			exonNode.setAttribute("end", "" + exon.getExonEndCoorPos());
			exonNode.setAttribute("modBy3", "" + exon.getModBy3());
			exonNode.setAttribute("IfAlternative", "" + exon.getIfAlternative());
			exonNode.setTextContent(exon.getSequenceAsString());
			exonsNode.appendChild(exonNode);
		}
		eventRoot.appendChild(exonsNode);
		
		Element alteventNode = doc.createElement("ucscaltevent");
		Iterator<Tris<String,Integer,Integer>> iteRegion = asRegions.iterator();
		while (iteRegion.hasNext()) {
			Tris<String,Integer,Integer> oneRegion = iteRegion.next();
			Element regionNode = doc.createElement("altRegion");
			
			regionNode.setAttribute("chr", "" + oneRegion.getValue1());
			regionNode.setAttribute("start", "" + oneRegion.getValue2());
			regionNode.setAttribute("end", "" + oneRegion.getValue3());
			
			//exonNode.setAttribute("IfAlternative", "" + exon.getIfAlternative());
			//exonNode.setTextContent(exon.getSequenceAsString());
			alteventNode.appendChild(regionNode);
		}
		eventRoot.appendChild(alteventNode);

		Element geneSeqNode = doc.createElement("geneSequence");
		geneSeqNode.setAttribute("start", "" + frag.getSeqBegPos());
		geneSeqNode.setAttribute("end", "" + frag.getSeqEndPos());
		geneSeqNode.setTextContent(frag.getSequenceOfTheGene());
		eventRoot.appendChild(geneSeqNode);

		Element asTypeNode = doc.createElement("asType");
		asTypeNode.setTextContent(asType.toString());
		eventRoot.appendChild(asTypeNode);
		// sequence

		Element seqNode = doc.createElement("sequenceOfExons");
		seqNode.setTextContent(frag.getSequence());
		eventRoot.appendChild(seqNode);
		
		
		Element conservationNode = doc.createElement("conservation");
		String result = "";
		for (int j = 0; j < conservationScore.size(); ++j) {

			result += conservationScore.get(j);

			if (conservationScore.size() - 1 != j)
				result += " ";
		}

		conservationNode.setTextContent(result);
		eventRoot.appendChild(conservationNode);

		// gene name
		// Element geneName = doc.createElement("ucsc_gene_name");
		// geneName.setTextContent(getGeneName());
		// eventRoot.appendChild(geneName);

		// if mod 3
		// Element mod3Node = doc.createElement("mod_by_3");
		// mod3Node.setTextContent("" + getMod3());
		// eventRoot.appendChild(mod3Node);

		// Element cds = doc.createElement("cds");
		// for (int i = 0; i < cdss.size(); ++i) {
		// Element p = doc.createElement("cds");
		// p.setTextContent(cdss.get(i));
		// cds.appendChild(p);
		// }
		// eventRoot.appendChild(cds);

		// pfam
		/*
		 * Element pfam = doc.createElement("pfam_information"); for (int i = 0;
		 * i < pfamInfo.size(); ++i) { Element p =
		 * doc.createElement("pfam_information_" + i);
		 * p.setTextContent(pfamInfo.get(i)); pfam.appendChild(p);
		 * 
		 * } eventRoot.appendChild(pfam);
		 */

		return eventRoot;
	}

}
/521            1404006139  1000  1000  100600  9075      `
package ASEvent;

import java.util.ArrayList;
import GeneStructure.Exon;
import GeneStructure.Frame;
import GeneStructure.Strand;
import Utility.Algorithm.Translate;
import Utility.SequenceFeatureWrapper.SequenceFeatureExtractor;

public class ASTranslateEngine {
	public ASTranslateEngine() {
		super();
	}

	/*
	 * this method is the realy work method
	 */
	public static void translate(Exon exon2, Exon exon1, Exon exon3,
			Strand strand, ArrayList<String> proSeqs, ArrayList<Frame> frames) {

		proSeqs.clear();
		// ArrayList<Integer>orfs=new ArrayList<Integer>();
		if (exon1.getExonLength() < 30 || exon3.getExonLength() < 30) {
			// orfs.add(-1);
			return;// orfs;
		}

		String seq;

		if (strand.equals(Strand.POSITIVE)) {
			int seqBeg = exon1.getExonBegCoorPos();
			seq = exon1.getSequenceAsString() + exon2.getSequenceAsString()
					+ exon3.getSequenceAsString();

			// DNASequence dna=new DNASequence(seq);
			int relativeExonBeg = exon1.getExonEndCoorPos()
					- exon1.getExonBegCoorPos() + 1 + 1;// 1-based index
			int relativeExonEnd = relativeExonBeg + exon2.getExonEndCoorPos()
					- exon2.getExonBegCoorPos();// 1-based index
			// frame one
			// String
			// s=dna.getRNASequence(Frame.ONE).getProteinSequence().getSequenceAsString();

			String s = Translate.translate(seq);
			if (testFrame(relativeExonBeg, relativeExonEnd, s, proSeqs, strand)) {
				frames.add(Frame.ONE);
			}

			// s=dna.getRNASequence(Frame.TWO).getProteinSequence().getSequenceAsString();
			s = Translate.translate(seq.substring(1));
			if (testFrame(relativeExonBeg + 1, relativeExonEnd + 1, s, proSeqs,
					strand)) {
				frames.add(Frame.TWO);
			}

			// s=dna.getRNASequence(Frame.THREE).getProteinSequence().getSequenceAsString();
			s = Translate.translate(seq.substring(2));
			if (testFrame(relativeExonBeg + 1, relativeExonEnd + 1, s, proSeqs,
					strand)) {
				frames.add(Frame.THREE);
			}

		}
		if (strand.equals(Strand.NEGATIVE)) {
			int seqEnd = exon3.getExonEndCoorPos();
			seq = exon1.getSequenceAsString() + exon2.getSequenceAsString()
					+ exon3.getSequenceAsString();
			seq = Translate.getReverseCompliment(seq);
			// DNASequence dna=new DNASequence(seq);

			// 3-1 4-2 5-1
			int relativeExonBeg = exon3.getExonEndCoorPos()
					- exon3.getExonBegCoorPos() + 2;// 1-based index
			int relativeExonEnd = relativeExonBeg + exon2.getExonEndCoorPos()
					- exon2.getExonBegCoorPos();// 1-based index
			// frame one
			// String
			// s=dna.getRNASequence(Frame.REVERSED_ONE).getProteinSequence().getSequenceAsString();
			String s = Translate.translate(seq);
			// s = new StringBuffer(s).reverse().toString();
			if (testFrame(relativeExonBeg, relativeExonEnd, s, proSeqs, strand)) {
				frames.add(Frame.ONE);
			}
			// s=dna.getRNASequence(Frame.REVERSED_TWO).getProteinSequence().getSequenceAsString();
			s = Translate.translate(seq.substring(1));
			// s = new StringBuffer(s).reverse().toString();
			if (testFrame(relativeExonBeg - 1, relativeExonEnd - 1, s, proSeqs,
					strand)) {
				frames.add(Frame.TWO);
			}

			// s=dna.getRNASequence(Frame.REVERSED_THREE).getProteinSequence().getSequenceAsString();
			s = Translate.translate(seq.substring(2));
			// s = new StringBuffer(s).reverse().toString();
			if (testFrame(relativeExonBeg - 2, relativeExonEnd - 2, s, proSeqs,
					strand)) {
				frames.add(Frame.THREE);
			}
			/*
			 * for(int i=0;i<orfs.size();++i){
			 * 
			 * if(orfs.get(i)==1) orfs.set(i, 3); }
			 * 
			 * for(int i=0;i<orfs.size();++i){ if(orfs.get(i)==0) orfs.set(i,
			 * 1); }
			 */
		}

		// return orfs;
		// return true;
	}

	private static boolean testFrame(int relativeExonBeg, int relativeExonEnd,
			String s, ArrayList<String> proSeqs, Strand strand) {
		int proteinBeg = (int) Math.ceil(relativeExonBeg / 3.0);
		int proteinEnd = (int) Math.floor(relativeExonEnd / 3.0);
		// int beg=0;
		// int end=s.length()-1;
		/*
		 * for(int i=0;i<proteinBeg;++i){ if(s.charAt(i)=='*') beg=i+1; }
		 * for(int i=s.length()-1;i>proteinEnd;--i){ if(s.charAt(i)=='*')
		 * end=i-1; }
		 * 
		 * 
		 * if(proteinBeg-beg<9||end-proteinEnd<9) return false;
		 * 
		 * 
		 * 
		 * for(int i=proteinBeg;i<proteinEnd;++i) if(s.charAt(i)=='*') return
		 * false;
		 * 
		 * for(int i=0;i<proteinEnd+10;++i) if(s.charAt(i)=='*') return false;
		 */

		if (proteinBeg < 9)
			return false;

		for (int i = 0; i < proteinEnd + 10; ++i) {
			if (s.charAt(i) == '*')
				return false;
		}

		int stopIndex = s.indexOf('*');
		if (stopIndex != -1) {
			s = s.substring(0, stopIndex);
		}

		if (strand.equals(Strand.POSITIVE)) {
			proSeqs.add(s);
			// proSeqs.add(new ProteinSequence(s.substring(beg, end)));

		} else {
			// for(int i=s.length()-1;i>proteinBeg-10;--i)
			// if(s.charAt(i)=='*')
			// return false;

			// s=s.substring(beg, end);
			// s = new StringBuffer(s).reverse().toString();
			proSeqs.add(s);

		}

		return true;
	}

	public static String translateARegion(String torg, String tchr, int tbeg,
			int tend, int tframe, Strand tstrand) {
		String dna = "";
		String protein = "";

		// dna = fais.getSequence(tchr, tbeg, tend).getSequenceAsString();
		dna = SequenceFeatureExtractor.getSequence(torg, tchr, tbeg, tend);

		if (dna.length() - tframe >= 3) {
			if (tstrand.equals(Strand.POSITIVE)) {
				// /String dnaStr=dna.substring(tframe,dna.length());
				// protein=(new
				// DNASequence(dna.substring(0,dna.length()))).getRNASequence(FrameConvertToInt.convertintToFrame(tframe)).getProteinSequence().getSequenceAsString();
				protein = Translate.translate(dna.substring(tframe));

			} else {
				// protein=(new
				// DNASequence(dna.substring(0,dna.length()))).getRNASequence(FrameConvertToInt.convertintToFrame(3+tframe)).getProteinSequence().getSequenceAsString();
				dna = Translate.getReverseCompliment(dna);
				protein = Translate.translate(dna.substring(tframe));

			}
		} else
			protein = dna;

		return protein;// +"\t"+dna;
	}

	public static void main(String[] args) {
		// DNASequence seq = new
		// DNASequence("ttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt");
		// seq.setBioBegin(1000);
		// seq.setBioEnd(1168);
		// DNASequence exon1=new DNASequence();
		// DNASequence exonAS=new DNASequence();

		// seq.setBioEnd();
		// ArrayList<Integer> x = translateASEvnet(seq, 1000, 1000 +
		// seq.getLength(), 1040, 1080, Strand.POSITIVE);
		// System.out.println(x.get(0));
		// System.out.println(ASTranslateEngine.testHasStopCodon(seq));

		// ASDebug.output(seq.getRNASequence().getProteinSequence().getSequenceAsString());
	}

	private static boolean testIfHaveStopCodon(String proStr, int exonLength) {
		int proteinLength = proStr.length();
		if (proteinLength * 3 + 2 < exonLength)
			return true;
		for (int i = 0; i < proteinLength; ++i) {
			if (proStr.charAt(i) == '*') {
				return true;
			}
		}

		return false;
	}

	public static void translateOnlyExon(Exon exon, Strand strand,
			ArrayList<String> proSeqs, ArrayList<Frame> frames) {
		Frame[] frame = { Frame.ONE, Frame.TWO, Frame.THREE };
		int exonLen = exon.getExonLength();

		if (strand.equals(Strand.POSITIVE)) {
			int exonBegPos = exon.getExonBegCoorPos();
			for (int i = 0; i < 3; ++i) {
				// ProteinSequence
				// protein=exon.getRNASequence(frame[i]).getProteinSequence();
				// ordinal is 0 based index

				String protein = Translate.translate(exon.getSequenceAsString()
						.substring(frame[i].ordinal()));
				String proStr = protein;
				if (exonLen - i < 3)
					continue;

				if (!testIfHaveStopCodon(proStr, exonLen - i)) {
					proSeqs.add(protein);
					frames.add(frame[i]);

				}

			}

		}

		if (strand.equals(Strand.NEGATIVE)) {
			int exonEndPos = exon.getExonEndCoorPos();
			for (int i = 0; i < 3; ++i) {
				String protein = Translate.getReverseCompliment(exon
						.getSequenceAsString().substring(frame[i].ordinal()));

				protein = Translate.translate(protein);

				// String proStr=protein.getSequenceAsString();

				if (exonLen - i + 3 < 3)
					continue;

				if (!testIfHaveStopCodon(protein, exonLen - i)) {
					proSeqs.add(protein);
					frames.add(frame[i]);

				}

			}

		}

	}

	public static String translateUniverse(String tsequence, Strand tstrand) {
		String seq = "";
		if (tstrand.equals(Strand.NEGATIVE)) {
			seq = Translate.getReverseCompliment(tsequence);
		} else {
			seq = tsequence;
		}

		String protein = Translate.translate(seq);

		return protein;

	}

}

/545            1392206959  1000  1000  100600  20        `
package ASEvent;

/564            1410431343  1000  1000  100600  8178      `
package ASEvent;

import java.util.ArrayList;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

import GeneStructure.Frame;
import GeneStructure.Strand;
import Utility.ProteinFeatureWrapper.ProteinFeatureExtractor;
import Utility.Structuure.DISTYPE;
import Utility.Structuure.Pair;
import Utility.Structuure.Quar;

public class EventIsoformFeature {
	
	private Pair<Integer, Integer> asPosition=new Pair<Integer,Integer>(-1,-1);

	public EventIsoformFeature(String tproteinSequence, Frame tframe,
			String tchr) {
		chr = tchr;

		proteinSequence = tproteinSequence;
		proteinSequenceSeq = proteinSequence;

		frame = tframe;
		init();

	}
	public EventIsoformFeature(String tproteinSequence,String tchr) {

		// transcriptBegPos=ttranscriptBegPos;
		// transcriptEndPos=ttranscriptEndPos;
		
		
		chr = tchr;

		proteinSequence = tproteinSequence;
		proteinSequenceSeq = proteinSequence;

		//asPosition.setValue1(tasPosition.getValue1());
		//asPosition.setValue2(tasPosition.getValue2());

		// frame = tframe;
		init();

	}
	public EventIsoformFeature(){
		
	}

	public EventIsoformFeature(String tproteinSequence, Frame tframe,String tchr,Pair<Integer,Integer> tasPosition) {

		// transcriptBegPos=ttranscriptBegPos;
		// transcriptEndPos=ttranscriptEndPos;
		
		
		chr = tchr;

		proteinSequence = tproteinSequence;
		proteinSequenceSeq = proteinSequence;

		asPosition.setValue1(tasPosition.getValue1());
		asPosition.setValue2(tasPosition.getValue2());

		// frame = tframe;
		init();

	}

	String chr;

	String proteinSequence;
	String proteinSequenceSeq;
	
	// alternative splicing information
	Frame frame = Frame.UNKNOWN;

	// orf information
	int orf = -1;

	private ArrayList<Quar<Integer, Integer, String, String>> pfamInfo = new ArrayList<Quar<Integer, Integer, String, String>>();

	// disprot information
	ArrayList<Double> disprotValue = new ArrayList<Double>();

	// disprot String
	String disprotStr = "";

	// alternative splicing disorder type
	DISTYPE distype = DISTYPE.UNKNOWN;
	
	DISTYPE distypeInASRegion=DISTYPE.UNKNOWN;

	// ptm information
	ArrayList<String> ptms = new ArrayList<String>();

	ArrayList<Pair<Integer, String>> uniPTMs = new ArrayList<Pair<Integer, String>>();

	private void init() {
		// TODO Auto-generated method stub
		pfamInfo = ProteinFeatureExtractor.getPfamQuar(proteinSequenceSeq,
				Strand.POSITIVE);

		disprotStr = ProteinFeatureExtractor.getDisProbability(
				proteinSequenceSeq, Strand.POSITIVE, disprotValue);
		distype = getDisorderType();
		distypeInASRegion=getDisorderTypeInASRegion();
		
		// pfamInfo=ProteinFeatureExtractor.
		// ptms = ProteinFeatureExtractor.getPTMs(proteinSequenceSeq);
		// ptms = modifyPtm(ptms);
		// uniPTMs=ProteinFeatureExtractor.getPTMUsingGeneName(chr,transcriptBegPos,transcriptEndPos,proteinSequenceSeq);

		// uniPTMs=modifyUniprotPtm(uniPTMs);
	}

	private ArrayList<Pair<Integer, String>> modifyUniprotPtm(
			ArrayList<Pair<Integer, String>> uniPTMs2) {

		ArrayList<Pair<Integer, String>> uniPTMInfo = new ArrayList<Pair<Integer, String>>();
		// TODO Auto-generated method stub
		for (Pair<Integer, String> a : uniPTMs) {
			int p = a.getValue1();

			uniPTMInfo.add(new Pair<Integer, String>(p, a.getValue2()));

		}

		return uniPTMInfo;
	}

	private ArrayList<String> modifyPtm(ArrayList<String> tptms) {

		// int asProteinBegPos = asPosition.getValue1();
		// int asProteinEndPos = asPosition.getValue2();

		for (int i = 0; i < tptms.size(); ++i) {
			String[] re = tptms.get(i).split("\\t");
			String posStr = re[0].substring(1);
			int pos = Integer.parseInt(posStr);
			// if (pos >= asProteinBegPos && pos <= asProteinEndPos)
			// tptms.set(i, tptms.get(i) + " In AS region ");

		}

		return tptms;
		// modPreds.add(ptms);
		// k++;
	}

	private DISTYPE getDisorderTypeInASRegion(){
		int asProteinBegPos = asPosition.getValue1();
		int asProteinEndPos = asPosition.getValue2();

		String asDomain = disprotStr.substring(asProteinBegPos - 1,
		asProteinEndPos - 1); // -1 convert to 0-based

		if (!asDomain.contains("o") && !asDomain.contains("."))
			return DISTYPE.FULLDISORDER; // full disorder
		else if (!asDomain.contains("D"))
			return DISTYPE.NODISORDER; // no disorder
		else
			return DISTYPE.PARTDISORDER; // partial disorder
		
	}
	
	private DISTYPE getDisorderType() {

		//return DISTYPE.UNKNOWN;

		 if (!disprotStr.contains("o") && !disprotStr.contains("."))
			 return DISTYPE.FULLDISORDER; // full disorder 
		 else if(!disprotStr.contains("D"))
			 return DISTYPE.NODISORDER; // no disorder
		 else 
			 return DISTYPE.PARTDISORDER; //partial disorder
		
	}

	public void processXMLProtein(Document doc, Element tableRoot,
			Element eventNode, int i) {
		Element proteinNode = doc.createElement("isoform");
		eventNode.appendChild(proteinNode);

		Element proteinSeqNode = doc.createElement("proteinSequence");

		proteinSeqNode.setTextContent(proteinSequenceSeq);
		proteinNode.appendChild(proteinSeqNode);

		Element proteinFrameNode = doc.createElement("frame");
		proteinFrameNode.setTextContent(frame.ordinal() + " ");
		proteinNode.appendChild(proteinFrameNode);

		// Element proteinOrfNode = doc.createElement("orf");
		// proteinOrfNode.setTextContent(frame.ordinal()+" ");
		// proteinNode.appendChild(proteinOrfNode);

		// Element proteinSequenceNode = doc.createElement("proteinSequence");
		// proteinSequenceNode.setTextContent(proteinSequenceSeq);
		// proteinNode.appendChild(proteinSequenceNode);
		Element asRegionNode=doc.createElement("asRegion");
		asRegionNode.setAttribute("start",""+ asPosition.getValue1());
		asRegionNode.setAttribute("end", ""+asPosition.getValue2());
		//asRegionNode.setTextContent("start="+asPosition.getValue1()+","+"end="+asPosition.getValue2());
		proteinNode.appendChild(asRegionNode);

		// pfam
		Element pfamsNode = doc.createElement("pfam_domains");
		for (Quar<Integer, Integer, String, String> itePfam : pfamInfo) {

			Element pfamNode = doc.createElement("pfam_domain");
			// p.setTextContent(pfamInfo.get(j));
			pfamNode.setAttribute("start", "" + itePfam.getValue1());
			pfamNode.setAttribute("end", "" + itePfam.getValue2());
			pfamNode.setAttribute("family", "" + itePfam.getValue3());
			pfamNode.setAttribute("description", itePfam.getValue4());
			pfamsNode.appendChild(pfamNode);

		}
		proteinNode.appendChild(pfamsNode);

		Element disValueNode = doc.createElement("disProt_value");
		String result = "";
		for (int j = 0; j < disprotValue.size(); ++j) {

			result += disprotValue.get(j);

			if (disprotValue.size() - 1 != j)
				result += " ";
		}

		disValueNode.setTextContent(result);
		disValueNode.setAttribute("disOrder_string", disprotStr);
		disValueNode.setAttribute("disOrder_type", distype.toString());
		disValueNode.setAttribute("disOrder_type_In_AS", distypeInASRegion.toString());

		proteinNode.appendChild(disValueNode);

		// Element disStrNode=doc.createElement("disProt_string");
		// disStrNode.setTextContent(disprotStr);
		// proteinNode.appendChild(disStrNode);

		// Element disTypeNode=doc.createElement("disProt_type");
		// disTypeNode.setTextContent(distype.toString());
		// proteinNode.appendChild(disTypeNode);

		// Element ptmsNode = doc.createElement("ptm");
		// String ptmStr="";
		// for (int j = 0; j < ptms.size(); ++j) {
		// Element p=doc.createElement("field"+j);
		// ptmStr += ptms.get(j);
		// p.setTextContent(ptms.get(j));

		// ptmsNode.appendChild(p);
		// }

		// ptmsNode.setTextContent(ptmStr);
		// proteinNode.appendChild(ptmsNode);

		Element uniprotptmsNode = doc.createElement("uniprotptm");
		// String ptmStr="";
		for (int j = 0; j < uniPTMs.size(); ++j) {
			Element p = doc.createElement("field" + j);
			// ptmStr += ptms.get(j);
			p.setTextContent(uniPTMs.get(j).toString());

			uniprotptmsNode.appendChild(p);
		}

		// ptmsNode.setTextContent(ptmStr);
		proteinNode.appendChild(uniprotptmsNode);

	}

}
Fragment.java/  1404006139  1000  1000  100664  2550      `
package ASEvent;

import java.util.ArrayList;
import java.util.Iterator;

import GeneStructure.Exon;
import GeneStructure.Strand;
import Utility.SequenceFeatureWrapper.SequenceFeatureExtractor;

public class Fragment {
	Fragment() {
		// chrosome=tchrosome;
	}

	String chrosome = "";
	String organism = "";

	/*
	 * store the exons
	 */
	ArrayList<Exon> exons = new ArrayList<Exon>();

	/*
	 * strand of the sequence
	 */
	public Strand strand;

	Exon getExon(int index) {
		return exons.get(index - 1);

	}

	public void setStrand(Strand tstrand) {
		strand = tstrand;
	}

	public void addExon(Exon exon) {
		exons.add(exon);

	}

	public void addExon(String torganism, String chr, int begPos, int endPos,
			Strand strand, boolean isConstitute) {
		// String dna = GetSequenceUsingRest.getDNASeg(organism, chr, beg, end);

		organism = torganism;
		chrosome = chr;
		String dna;
		dna = SequenceFeatureExtractor.getSequence(organism, chr, begPos,
				endPos);

		this.setStrand(strand);
		Exon x = new Exon(organism, chr, dna);

		x.setExonBegCoorPos(begPos);
		x.setExonEndCoorPos(endPos);
		x.setAlternative(isConstitute);

		this.addExon(x);

	}

	public void addExon(String organism, String chr, int begPos, int endPos,
			Strand strand) {
		// String dna = GetSequenceUsingRest.getDNASeg(organism, chr, beg, end);

		chrosome = chr;
		String dna;
		dna = SequenceFeatureExtractor.getSequence(organism, chr, begPos,
				endPos);

		this.setStrand(strand);
		Exon x = new Exon(organism, chr, dna);

		x.setExonBegCoorPos(begPos);
		x.setExonEndCoorPos(endPos);

		this.addExon(x);

	}

	public int getExonLenght(int i) {
		return exons.get(i - 1).getExonLength();

	}

	public String getSequence() {
		String tseq = "";

		for (int i = 0; i < exons.size(); ++i) {
			tseq += exons.get(i).getSequenceAsString();
		}

		return tseq;

	}

	public String getSequenceWithoutASExons() {
		String result = "";

		for (Exon e : exons) {
			if (!e.getIfAlternative())
				result += e.getSequenceAsString();

		}

		return result;
	}

	public int getSeqBegPos() {
		return exons.get(0).getExonBegCoorPos();
	}

	public int getSeqEndPos() {
		return exons.get(exons.size() - 1).getExonEndCoorPos();

	}

	public Iterator<Exon> getExonsIterator() {
		return exons.iterator();

	}

	public String getSequenceOfTheGene() {
		int begPos = getSeqBegPos();
		int endPos = getSeqEndPos();

		String dna = SequenceFeatureExtractor.getSequence(organism, chrosome,
				begPos, endPos);

		return dna;

	}
	// get exon is 1 bsed index public Exon getExon(int i){

}
/590            1404006139  1000  1000  100664  2683      `
package ASEvent;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;

import ASEvent.GTFFeature.GTFFeature;
import Utility.SequenceFeatureWrapper.DatabaseUCSC;
import Utility.SequenceFeatureWrapper.SequenceFeatureExtractor;

public class ASEventBrowserTranscriptID extends ASEventBrowserExons {

	public ASEventBrowserTranscriptID(String toneEvent, String torganism) {

		super(toneEvent, torganism);
		oneEvent = parseDIToExons(toneEvent);

		// TODO Auto-generated constructor stub
	}

	private class ComparatorGTFFeature implements Comparator<GTFFeature> {

		@Override
		public int compare(GTFFeature o1, GTFFeature o2) {
			// TODO Auto-generated method stub
			return o1.getStart() - o2.getStart();

			// return 0;
		}

	}

	private String idConvertor(String id) {
		if (id.startsWith("uc"))
			return DatabaseUCSC.ucscTranscriptNameToEnsemblName(id);

		if (id.startsWith("NM"))
			return DatabaseUCSC.refseqTNameToEnsemblName(id);

		return id;
	}

	private String parseDIToExons(String toneEvent) {
		// TODO Auto-generated method stub
		String[] a = toneEvent.split("@");

		String transcriptId = idConvertor(a[0]);
		this.id = transcriptId;

		String[] positions = a[1].split(":");
		HashSet<Integer> pos = new HashSet<Integer>();

		for (int i = 0; i < positions.length; ++i) {
			pos.add(Integer.parseInt(positions[i]));

		}

		ArrayList<GTFFeature> gtfFeatures = SequenceFeatureExtractor
				.getTranscriptsOfATranscript(transcriptId);
		/*
		 * ArrayList<GTFFeature> gtfFeatures = new ArrayList<GTFFeature>();
		 * 
		 * String[] gffs = gff.split("\n"); GTFCode c = new GTFCode(); for (int
		 * i = 0; i < gffs.length; ++i) { if (gffs[i].startsWith("#")) continue;
		 * 
		 * gtfFeatures.add(c.decode(gffs[i]));
		 * 
		 * }
		 */

		Collections.sort(gtfFeatures, new ComparatorGTFFeature());

		String exons = "";

		int exonIndex = 1;
		for (GTFFeature itegtf : gtfFeatures) {
			String attr = itegtf.getAttribute();
			String[] attLine = attr.split(";");

			String ttranscriptId = "";
			for (int i = 0; i < attLine.length; ++i) {
				if (attLine[i].contains("transcript_id")) {
					// cds+=attLine[i];
					ttranscriptId = attLine[i].substring(16, 31);

				}
				// cdss.add(cds);
			}
			if (transcriptId.equalsIgnoreCase(ttranscriptId)) {
				exons += "@" + itegtf.getChr() + ":" + itegtf.getStart() + ":"
						+ itegtf.getEnd() + ":" + itegtf.getStrand().toSymbol();// //here
																				// bug

				if (pos.contains(exonIndex)) {
					exons += ":splice";
				}
				exonIndex++;
			}

		}

		if (exons.length() == 0)
			return "";

		return exons.substring(1);// cut the first @
	}

}

/623            1410430422  1000  1000  100664  3756      `
package ASEvent;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

import Utility.ASDebug;
import Utility.Structuure.ConfigureASEvent;

public class BatchProcess {
	
	BatchProcess() {

	}

	private ArrayList<String> pos = new ArrayList<String>();

	void outputXML(Document doc, String fileName) {
		TransformerFactory transformerFactory = TransformerFactory
				.newInstance();
		Transformer transformer;
		try {
			transformer = transformerFactory.newTransformer();

			DOMSource source = new DOMSource(doc);
			StreamResult result = new StreamResult(new File(fileName));

			// Output to console for testing
			// StreamResult result = new StreamResult(System.out);

			transformer.transform(source, result);
		} catch (TransformerConfigurationException e) {
			System.out.println(e.getMessage());
		} catch (TransformerException e) {
			System.out.println(e.getMessage());
		}
	}

	void batchProcessed(String organism, String outputFileName)
			throws ParserConfigurationException, IOException {

		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		DocumentBuilder db;

		PrintWriter pw = new PrintWriter(new FileWriter("debug.txt"));

		db = dbf.newDocumentBuilder();

		// System.out.println(x);
		Document doc = db.newDocument();

		// Document doc = db.parse(new File("meng.xml"));
		Element tableRoot = doc.createElement("root");
		doc.appendChild(tableRoot);

		ArrayList<ASevent> table = new ArrayList<ASevent>();

		for (int i = 0; i < pos.size(); ++i) {
			try {
				ASDebug.output("current position=" + pos.get(i));

				ASevent p = new ASEventMiso(pos.get(i), organism,true);
				p.init();
				p.processXML(doc, tableRoot);

				table.add(p);
			} catch (Exception e) {
				System.out.println(e.getMessage());
				System.out.println(e.getStackTrace());

				pw.println(pos.get(i));
			}

		}
		if (outputFileName.length() == 0)
			outputXML(doc, "all.xml");
		else
			outputXML(doc, outputFileName);

		pw.flush();
		pw.close();

	}

	void readPositionsFile(String fileName) {
		File file = new File(fileName);
		BufferedReader input;
		try {
			input = new BufferedReader(new FileReader(file));

			String text;

			while ((text = input.readLine()) != null)
				pos.add(text);

		} catch (FileNotFoundException e) {
			System.out.println(e.getMessage());
		} catch (IOException e) {
			System.out.println(e.getMessage());
		}
	}

	public static void main(String[] args) {
		String configureFileName = "/home/limeng/alternative/Configure.txt";
		String org = "hg19";
		String fileName = "/home/limeng/alternative/zhouao-6-6/sample.txt";

		// String configureFileName=args[0];
		// String org=args[1];
		// String fileName=args[2];

		ConfigureASEvent.readConfigureFromFile(configureFileName);
		BatchProcess table = new BatchProcess();
		table.readPositionsFile(fileName);

		try {

			table.batchProcessed(org,
					"/home/limeng/alternative/zhouao-6-6/AS.hg19.short-event.xml");

		} catch (ParserConfigurationException e) {
			System.out.println(e.getMessage());
		} catch (IOException e) {
			System.out.println(e.getMessage());
		}
		
	}
	
	
}
/642            1410427215  1000  1000  100664  8646      `
package ASEvent;

import java.util.ArrayList;
import java.util.regex.Pattern;

import GeneStructure.Frame;
import GeneStructure.Strand;
import Utility.ASDebug;
import Utility.Structuure.ASTYPE;
import Utility.Structuure.Pair;

public class ASEventMiso extends ASevent {

	public ASEventMiso(String toneEvent, String torganism) {
		super(toneEvent, torganism);

		// TODO Auto-generated constructor stub
	}
	
	public ASEventMiso(String toneEvent, String torganism,boolean toutputAllIsoform) {
		super(toneEvent, torganism);
		
		outputAllIsoform=toutputAllIsoform;
		// TODO Auto-generated constructor stub
	}
	
	private boolean outputAllIsoform=false;
	
	public static String regexCasseteExon = "chr\\w+:(\\d+):(\\d+):(\\+|-)@chr\\w+:(\\d+):(\\d+):(\\+|-)@chr\\w+:(\\d+):(\\d+):(\\+|-)";

	public static String regexA5SS = "chr\\w+:(\\d+):(\\d+)\\|(\\d+):(\\+|-)@chr(\\w+):(\\d+):(\\d+):(\\+|-)";

	public static String regexA3SS = "chr(\\w+):(\\d+):(\\d+):(\\+|-)@chr\\w+:(\\d+)\\|(\\d+):(\\d+):(\\+|-)";

	public static String regexRetainedIntro = "chr(\\w+):(\\d+)-(\\d+):(\\+|-)@chr(\\w+):(\\d+)-(\\d+):(\\+|-)";

	private void buildGeneFragPostive() {
		String[] args = oneEvent.split("\\@", 20);
		if (asType.equals(ASTYPE.SE)) {

			for (int i = 0; i < args.length; ++i) {
				String[] quer = args[i].split("\\:", 20);
				int beg = Integer.parseInt(quer[1]);
				int end = Integer.parseInt(quer[2]);

				frag.addExon(organism, quer[0], beg, end, strand);
				chr = quer[0];
			}

		}

		if (asType.equals(ASTYPE.RI)) {

			String[] quert = args[0].split("\\:", 20);
			chr = quert[0];

			String[] quer = quert[1].split("-", 20);
			int beg1 = Integer.parseInt(quer[0]);
			int end1 = Integer.parseInt(quer[1]);

			frag.addExon(organism, chr, beg1, end1, strand);

			quert = args[1].split("\\:", 20);
			quer = quert[1].split("-", 20);

			int beg2 = Integer.parseInt(quer[0]);
			int end2 = Integer.parseInt(quer[1]);
			frag.addExon(organism, chr, end1 + 1, beg2 - 1, strand);
			frag.addExon(organism, chr, beg2, end2, strand);

		}

		if (asType.equals(ASTYPE.A5SS)) {

			String[] quer = args[0].split("\\:", 20);
			String[] begs = quer[2].split("\\|");
			int beg = Integer.parseInt(quer[1]);

			int end = Integer.parseInt(begs[1]);
			int endAS = Integer.parseInt(begs[0]);

			frag.addExon(organism, quer[0], beg, endAS, strand);
			frag.addExon(organism, quer[0], endAS + 1, end, strand);

			quer = args[1].split("\\:", 20);
			beg = Integer.parseInt(quer[1]);
			end = Integer.parseInt(quer[2]);
			frag.addExon(organism, quer[0], beg, end, strand);
			chr = quer[0];

		}

		if (asType.equals(ASTYPE.A3SS)) {

			String[] quer = args[0].split("\\:", 20);
			int beg = Integer.parseInt(quer[1]);
			int end = Integer.parseInt(quer[2]);

			frag.addExon(organism, quer[0], beg, end, strand);

			quer = args[1].split("\\:", 20);
			String[] ends = quer[1].split("\\|");

			end = Integer.parseInt(quer[2]);
			beg = Integer.parseInt(ends[0]);
			int begAS = Integer.parseInt(ends[1]);

			frag.addExon(organism, quer[0], beg, begAS - 1, strand);
			frag.addExon(organism, quer[0], begAS, end, strand);
			chr = quer[0];

		}

	}

	private void buildGeneFragNegative() {
		String[] args = oneEvent.split("\\@", 20);
		if (asType.equals(ASTYPE.SE)) {

			for (int i = args.length - 1; i >= 0; --i) {
				String[] quer = args[i].split("\\:", 20);
				int beg = Integer.parseInt(quer[1]);
				int end = Integer.parseInt(quer[2]);

				frag.addExon(organism, quer[0], beg, end, strand);
				chr = quer[0];

			}

		}

		if (asType.equals(ASTYPE.RI)) {

			String[] quert = args[1].split("\\:", 20);
			chr = quert[0];
			String[] quer = quert[1].split("-", 20);

			int beg1 = Integer.parseInt(quer[1]);
			int end1 = Integer.parseInt(quer[0]);

			frag.addExon(organism, chr, beg1, end1, strand);

			quert = args[0].split("\\:", 20);
			quer = quert[1].split("-", 20);

			int beg2 = Integer.parseInt(quer[1]);
			int end2 = Integer.parseInt(quer[0]);
			frag.addExon(organism, chr, end1 + 1, beg2 - 1, strand);
			frag.addExon(organism, chr, beg2, end2, strand);

		}

		if (asType.equals(ASTYPE.A5SS)) {

			String[] quer = args[1].split("\\:", 20);
			int beg = Integer.parseInt(quer[1]);
			int end = Integer.parseInt(quer[2]);
			frag.addExon(organism, quer[0], beg, end, strand);

			quer = args[0].split("\\:", 20);
			String[] begs = quer[2].split("\\|");
			end = Integer.parseInt(quer[1]);

			beg = Integer.parseInt(begs[1]);
			int begAS = Integer.parseInt(begs[0]);

			frag.addExon(organism, quer[0], begAS, beg - 1, strand);
			frag.addExon(organism, quer[0], beg, end, strand);
			chr = quer[0];

		}

		if (asType.equals(ASTYPE.A3SS)) {
			String[] quer = args[1].split("\\:", 20);
			String[] ends = quer[1].split("\\|");

			int beg = Integer.parseInt(quer[2]);
			int endAS = Integer.parseInt(ends[0]);
			int end = Integer.parseInt(ends[1]);

			frag.addExon(organism, quer[0], beg, endAS, strand);
			frag.addExon(organism, quer[0], endAS + 1, end, strand);
			quer = args[0].split("\\:", 20);
			beg = Integer.parseInt(quer[1]);
			end = Integer.parseInt(quer[2]);

			frag.addExon(organism, quer[0], beg, end, strand);
			chr = quer[0];

		}
	}

	protected void buildGeneFrag() {
		if (oneEvent.endsWith("-")) {
			strand = Strand.NEGATIVE;
			buildGeneFragNegative();
		} else {
			strand = Strand.POSITIVE;
			buildGeneFragPostive();
		}
		// chr=chr.substring(3);
		frag.getExon(2).setAlternative(true);
		
	}

	protected ASTYPE tellASType(String pos) {
		if (Pattern.matches(regexCasseteExon, pos.subSequence(0, pos.length())))
			return ASTYPE.SE;
		else if (Pattern.matches(regexA5SS, pos.subSequence(0, pos.length())))
			return ASTYPE.A5SS;
		else if (Pattern.matches(regexA3SS, pos.subSequence(0, pos.length())))
			return ASTYPE.A3SS;
		else if (Pattern.matches(regexRetainedIntro,
				pos.subSequence(0, pos.length())))
			return ASTYPE.RI;

		return ASTYPE.UNKNOWN;
	}

	
	protected void translate() {
		ArrayList<String> proSeqs = new ArrayList<String>();
		ArrayList<Frame> frames = new ArrayList<Frame>();

		ASTranslateEngine.translate(frag.getExon(2), frag.getExon(1),
				frag.getExon(3), strand, proSeqs, frames);

		for (int i = 0; i < proSeqs.size(); ++i) {
			Pair<Integer, Integer> asPosInProtein =getASPositionInProtein(frames.get(i));

			ASDebug.output(proSeqs.get(i));

			EventIsoformFeature a = new EventIsoformFeature(proSeqs.get(i),
					frames.get(i), chr,asPosInProtein);

			eventIsoforms.add(a);

		}
		if(!outputAllIsoform){
		//get the longest isoform
		int longestIndex=-1;
		int longestLength=-1;
		//ArrayList<Integer> proteinsLength=new ArrayList<Integer>();
		EventIsoformFeature longestIsoform=new EventIsoformFeature();
		
		for(int i=0;i<eventIsoforms.size();++i){
			int l=eventIsoforms.get(i).proteinSequence.length();
			if(l>longestLength){
				longestIndex=i;
			}
			
			
		}
		if(longestIndex>=0){
			longestIsoform=eventIsoforms.get(longestIndex);
		
			eventIsoforms.clear();
			eventIsoforms.add(longestIsoform);
			
		}
		}
		//eventIsoforms.remove(index)
		
		
	}

	private Pair<Integer, Integer> getASPositionInProtein(Frame tframe) {
		int asProteinBegPos = 0;
		int asProteinEndPos = 0;
		if (strand.equals(Strand.POSITIVE)) {
			int asProteinBegLen = frag.getExon(1).getExonLength();
			int asProteinEndLen = frag.getExon(1).getExonLength()
					+ frag.getExon(2).getExonLength();
			// switch(frames.get(i)){
			if (tframe.equals(Frame.ONE)) {
				asProteinBegPos = asProteinBegLen / 3;
			}
			if (tframe.equals(Frame.TWO)) {
				asProteinBegPos = (asProteinBegLen - 1) / 3;
			}
			if (tframe.equals(Frame.THREE)) {
				asProteinBegPos = (asProteinBegLen - 2) / 3;
			}
			asProteinBegPos += 1;
			asProteinEndPos = (asProteinEndLen + 1) / 3;

			return new Pair<Integer, Integer>(asProteinBegPos, asProteinEndPos);

			// asExonProteinPosition.add(new Pair<Integer,
			// Integer>(asProteinBegPos, asProteinEndPos));

		} else {
			int asProteinBegLen = frag.getExon(3).getExonLength();

			int asProteinEndLen = frag.getExon(3).getExonLength()
					+ frag.getExon(2).getExonLength();
			// switch(frames.get(i)){
			if (tframe.equals(Frame.ONE)) {
				asProteinBegPos = asProteinBegLen / 3;
			}
			if (tframe.equals(Frame.TWO)) {
				asProteinBegPos = (asProteinBegLen - 1) / 3;
			}
			if (tframe.equals(Frame.THREE)) {
				asProteinBegPos = (asProteinBegLen - 2) / 3;
			}

			asProteinBegPos += 1;
			asProteinEndPos = (asProteinEndLen + 1) / 3;

			return new Pair<Integer, Integer>(asProteinBegPos, asProteinEndPos);

			// asExonProteinPosition.add(new Pair<Integer,
			// Integer>(asProteinBegPos, asProteinEndPos));

		}
	}

}
/660            1404628502  1000  1000  100664  2309      `
package ASEvent;

import java.util.ArrayList;

import GeneStructure.Strand;
import Utility.ASDebug;
import Utility.Structuure.ASTYPE;

public class ASEventBrowserExons extends ASevent {

	public ASEventBrowserExons(String toneEvent, String torganism) {
		super(toneEvent, torganism);
		// TODO Auto-generated constructor stub
	}

	protected void buildGeneFrag() {
		String[] exonPos = oneEvent.split("\\@", 1000);
		for (int i = 0; i < exonPos.length; ++i) {
			String[] oneExon = exonPos[i].split("\\:", 5);

			if (oneExon[0].startsWith("chr"))
				chr = oneExon[0];

			String strandStr = oneExon[3];

			if (strandStr.equals("-")) {
				strand = Strand.NEGATIVE;
			} else {
				strand = Strand.POSITIVE;
			}

			boolean isAlternative = false;
			if (oneExon.length >= 5 && oneExon[4].equalsIgnoreCase("Splice")) {
				isAlternative = true;
			}

			int beg = Integer.parseInt(oneExon[1]);
			int end = Integer.parseInt(oneExon[2]);

			frag.addExon(organism, chr, beg, end, strand, isAlternative);

		}

		// chr=chr.substring(3);
	}

	protected ASTYPE tellASType(String pos) {

		return ASTYPE.UNKNOWN;
	}

	@Override
	protected void translate() {
		// TODO Auto-generated method stub
		ArrayList<String> proSeqs = new ArrayList<String>();
		// ArrayList<Frame> frames = new ArrayList<Frame>();

		// ASTranslateEngine.translate(frag.getExon(2),
		// frag.getExon(1),frag.getExon(3), strand, proSeqs, frames);
		for (int i = 0; i < 2; ++i) {

			String protein = "";
			if (0 == i)
				protein = ASTranslateEngine.translateUniverse(
						frag.getSequence(), strand);
			else
				protein = ASTranslateEngine.translateUniverse(
						frag.getSequenceWithoutASExons(), strand);
			
			int stopCodonIndex=protein.indexOf("*");
			if(stopCodonIndex!=-1)
				protein=protein.substring(0,stopCodonIndex);

			proSeqs.add(protein);

			ASDebug.output(protein);

			EventIsoformFeature a = new EventIsoformFeature(proSeqs.get(i), chr);

			eventIsoforms.add(a);

		}

		/*
		 * for (int i = 0; i < proSeqs.size(); ++i) { //Pair<Integer, Integer>
		 * asPosInProtein = getASPositionInProtein(frames.get(i));
		 * 
		 * ASDebug.output(proSeqs.get(i));
		 * 
		 * EventIsoformFeature a = new EventIsoformFeature(proSeqs.get(i),
		 * frames.get(i), chr);
		 * 
		 * eventIsoforms.add(a);
		 * 
		 * }
		 */

	}

}

/686            1404375152  1000  1000  100664  7262      `
package ASEvent;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import Utility.SequenceFeatureWrapper.SequenceFeatureExtractor;
import ASEvent.GTFFeature.GTFFeature;
import GeneStructure.Exon;
import GeneStructure.Transcript;

public class GetTranscirpts {

	ArrayList<Transcript> transcripts = new ArrayList<Transcript>();

	Transcript transcript = new Transcript();

	void run() {

		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		DocumentBuilder db = null;

		try {
			db = dbf.newDocumentBuilder();
		} catch (ParserConfigurationException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}

		// System.out.println(x);
		Document doc = db.newDocument();

		// Document doc = db.parse(new File("meng.xml"));
		Element tableRoot = doc.createElement("root");
		doc.appendChild(tableRoot);

		// ArrayList<ASevent> table = new ArrayList<ASevent>();

		try {
			getTranscripts("ENST00000455263", "hg19");
			HashSet<Integer> asExons = new HashSet<Integer>();
			asExons.add(2);
			asExons.add(3);
			getTranscript("ENST00000455263", "hg19", asExons);

			Element eventRoot = doc.createElement("event");
			tableRoot.appendChild(eventRoot);

			processXMLTranscript(doc, eventRoot);
			processXMLTranscripts(doc, eventRoot);

			// ASevent p = new ASEventBrowserTranscriptID("ENST00000455263@2:3",
			// "hg19");
			// p.init();
			// p.processXML(doc, tableRoot);
			// table.add(p);

		} catch (Exception e) {
			System.out.println(e.getMessage());
			System.out.println(e.getStackTrace());

		}

		outputXML(doc, "/home/limeng/alternative/browserhome/transcript.xml");

	}

	private void processXMLTranscript(Document doc, Element tableRoot) {
		// Element eventRoot = doc.createElement("event");
		// tableRoot.appendChild(eventRoot);

		Element transcriptNode = doc.createElement("alternativeExons");

		Iterator<Exon> iteExon = transcript.getExonIterator();
		while (iteExon.hasNext()) {
			Exon exon = iteExon.next();
			Element exonNode = doc.createElement("exon");
			exonNode.setAttribute("start", "" + exon.getExonBegCoorPos());
			exonNode.setAttribute("end", "" + exon.getExonEndCoorPos());
			exonNode.setAttribute("modBy3", "" + exon.getModBy3());
			exonNode.setAttribute("IfAlternative", "" + exon.getIfAlternative());
			exonNode.setTextContent(exon.getSequenceAsString());
			transcriptNode.appendChild(exonNode);
		}

		tableRoot.appendChild(transcriptNode);

	}

	public void processXMLTranscripts(Document doc, Element tableRoot) {
		// Element eventRoot = doc.createElement("event");
		// tableRoot.appendChild(eventRoot);

		Element transcriptsNode = doc.createElement("transcripts");
		Iterator<Transcript> iteTranscript = transcripts.iterator();
		while (iteTranscript.hasNext()) {
			Transcript t = iteTranscript.next();
			Element exonsNode = doc.createElement("transcript");
			exonsNode.setAttribute("ID", t.getTranscriptName());
			
			Iterator<Exon> iteExon = t.getExonIterator();
			while (iteExon.hasNext()) {
				Exon exon = iteExon.next();
				Element exonNode = doc.createElement("exon");
				exonNode.setAttribute("start", "" + exon.getExonBegCoorPos());
				exonNode.setAttribute("end", "" + exon.getExonEndCoorPos());
				exonNode.setAttribute("modBy3", "" + exon.getModBy3());
				exonNode.setAttribute("IfAlternative",
						"" + exon.getIfAlternative());
				exonNode.setTextContent(exon.getSequenceAsString());
				exonsNode.appendChild(exonNode);
			}
			transcriptsNode.appendChild(exonsNode);

		}
		tableRoot.appendChild(transcriptsNode);

	}

	void outputXML(Document doc, String fileName) {
		TransformerFactory transformerFactory = TransformerFactory
				.newInstance();
		Transformer transformer;
		try {
			transformer = transformerFactory.newTransformer();

			DOMSource source = new DOMSource(doc);
			StreamResult result = new StreamResult(new File(fileName));

			// Output to console for testing
			// StreamResult result = new StreamResult(System.out);

			transformer.transform(source, result);
		} catch (TransformerConfigurationException e) {
			System.out.println(e.getMessage());
		} catch (TransformerException e) {
			System.out.println(e.getMessage());
		}
	}

	void getTranscript(String ensemblTranscriptID, String org,
			HashSet<Integer> asPosition) {
		ArrayList<GTFFeature> features = SequenceFeatureExtractor
				.getTranscriptsOfATranscript(ensemblTranscriptID);

		int exonIndex = 1;
		for (int i = 0; i < features.size(); ++i) {
			GTFFeature feature = features.get(i);
			// ASDebug.output(i);

			String attr = features.get(i).getAttribute();
			String[] attrLines = attr.split("\\;");
			String transcriptid = "";
			for (int j = 0; j < attrLines.length; ++j) {
				// if (attrLines[j].contains("Parent")) {
				// cds+=attLine[i];
				// transcriptid = attrLines[j].substring(7);
				if (attrLines[i].contains("transcript_id")) {
					// cds+=attLine[i];
					transcriptid = attrLines[i].substring(16, 31);

					// transcriptid =
					// transcriptid.substring(1,transcriptid.length() - 1);

					// transcriptIDs.add(t);

				}
				// cdss.add(cds);
			}
			if (transcriptid.equals(ensemblTranscriptID)) {

				Exon e = new Exon("hg19", feature.getChr(), "",
						feature.getStart(), feature.getEnd());

				if (asPosition.contains(exonIndex))
					e.setAlternative(true);

				transcript.addExon(e);

				exonIndex++;
			}

		}
	}

	public void getTranscripts(String ensemblTranscriptID, String org) {

		ArrayList<GTFFeature> features = SequenceFeatureExtractor
				.getTranscriptsOfATranscript(ensemblTranscriptID);

		HashMap<String, Integer> transcriptIDMap = new HashMap<String, Integer>();

		int transcriptIndex = 0;
		for (int i = 0; i < features.size(); ++i) {
			GTFFeature feature = features.get(i);
			// ASDebug.output(i);

			String attr = features.get(i).getAttribute();
			String[] attrLines = attr.split("\\;");
			String transcriptid = "";
			for (int j = 0; j < attrLines.length; ++j) {
				if (attrLines[j].contains("transcript_id")) {
					// cds+=attLine[i];
					transcriptid = attrLines[j].substring(16, 31);
					
				}
				
			}

			if (transcriptIDMap.containsKey(transcriptid)) {
				transcripts.get(transcriptIDMap.get(transcriptid)).addExon(
						new Exon("hg19", feature.getChr(), "", feature
								.getStart(), feature.getEnd()));

			} else {
				transcriptIDMap.put(transcriptid, transcriptIndex++);
				Transcript t = new Transcript();
				t.setTranscriptName(transcriptid);
				
				t.addExon(new Exon("hg19", feature.getChr(), "", feature
						.getStart(), feature.getEnd()));
				transcripts.add(t);

			}

		}

	}

	public static void main(String[] args) {
		GetTranscirpts a = new GetTranscirpts();
		a.run();

	}

}
Strand.java/    1404006139  1000  1000  100664  276       `
package GeneStructure;

public enum Strand {
	NEGATIVE {
		public String toSymbol() {
			return "-";
		}
	},
	POSITIVE {
		public String toSymbol() {
			return "+";
		}
	},

	UNKNOWN {
		public String toSymbol() {
			return "*";
		}
	};

	public abstract String toSymbol();
}
Frame.java/     1404006139  1000  1000  100664  72        `
package GeneStructure;

public enum Frame {
	ONE, TWO, THREE, UNKNOWN
}
Exon.java/      1404006139  1000  1000  100664  1208      `
package GeneStructure;

public class Exon {
	public Exon(String torg, String tchr, String tseq, int tbegPos, int tendPos) {
		org = torg;
		tchr = chr;
		sequence = tseq;

		begPos = tbegPos;
		endPos = tendPos;

	}

	public Exon(String torg, String tchr, String tseq) {
		org = torg;
		tchr = chr;
		sequence = tseq;

	}

	public Exon(String tseq) {
		sequence = tseq;

	}

	public void setExonBegCoorPos(int tbegpos) {
		begPos = tbegpos;
	}

	public void setExonEndCoorPos(int tendpos) {
		endPos = tendpos;
	}

	public void setAlternative(boolean tisAlternative) {
		isAlternative = tisAlternative;

	}

	public boolean getIfAlternative() {
		return isAlternative;
	}

	private String name;

	private String sequence;

	private boolean isAlternative = false;

	private String org = "";

	private String chr = "";

	private int begPos = -1;

	private int endPos = -1;

	private int modBy3 = -1;

	public int getModBy3() {

		return (endPos - begPos + 1) % 3;

	}

	public int getExonBegCoorPos() {
		return begPos;

	}

	public int getExonEndCoorPos() {
		return endPos;

	}

	public int getExonLength() {
		return endPos - begPos + 1;

	}

	public String getSequenceAsString() {
		return sequence;

	}
}
Transcript.java/1404006139  1000  1000  100664  477       `
package GeneStructure;

import java.util.ArrayList;
import java.util.Iterator;

public class Transcript {
	public Transcript() {

	}

	public void setTranscriptName(String tname) {
		name = tname;

	}

	public String getTranscriptName() {
		return name;

	}

	private String name;

	private ArrayList<Exon> exons = new ArrayList<Exon>();

	public void addExon(Exon texon) {
		exons.add(texon);

	}

	public Iterator<Exon> getExonIterator() {

		return exons.iterator();

	}

}

/707            1408523427  1000  1000  100664  2085      `
package Utility;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;

import Utility.Structuure.ConfigureASEvent;

public class IndexWigFix {
	
	public static void index(String fileName){
		String text="";
		int line = 1;
		long numberOfBytes=0;
		
		try {
			PrintWriter pw = new PrintWriter(new FileWriter(fileName+".index"));

			File file = new File(fileName);
			BufferedReader input;

			input = new BufferedReader(new FileReader(file));
			
			ArrayList<String> indexes=new ArrayList<String>();
			int length=0;
			while ((text = input.readLine()) != null) {
				numberOfBytes+=text.length()+1;
				//if(line>2)
				//	break;
				if(text.startsWith("fixedStep")){
					
					indexes.add(text+" numberOfBytes="+numberOfBytes);
					if(line!=1){
						indexes.set(indexes.size()-2, indexes.get(indexes.size()-2)+" length="+length);
						
					}
					
					length=0;
					
				}
				length++;
	
				
				line++;
				
			}
			
			indexes.set(indexes.size()-1, indexes.get(indexes.size()-1)+" length="+length);

			for(String ite:indexes){
				pw.println(ite);
				
			}
			
			
			input.close();
			pw.close();
			
		} catch (FileNotFoundException e) {
			System.out.println(e.getMessage());
		} catch (IOException e) {
			System.out.println(e.getMessage());
		}
		
		
	}
	
	public static void indexAll(String fileName){
		ConfigureASEvent.readConfigureFromFile(fileName);
		String path=ConfigureASEvent.getConfigure().get("conservationPath");
		File gtf = new File(path);
		String[] names = gtf.list();
		for(String onePath:names){
			
			String oneFileName = path + onePath;
			System.out.println(oneFileName);
			if(oneFileName.endsWith("wigFix"))
				index(oneFileName);
			
		}
		
	}
	
	public static void main(String[] args){
		//indexAll("/home/limeng/alternative/Configure.txt");
		//indexAll(args[0]);
		
		index("/home/limeng/alternative/conservation/chr14.phastCons100way.wigFix");
		
	}
	

}

/725            1392209536  1000  1000  100600  20        `
package Utility;

ASDebug.java/   1404006139  1000  1000  100600  864       `
package Utility;

import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

public class ASDebug {
	public ASDebug() {
		super();

	}

	public static void close() {
		// pw.close();
	}

	static void init() {
		/*
		 * try { //pw= new PrintWriter(new FileWriter("debug.txt"));
		 * 
		 * //pw= new PrintWriter(new
		 * FileWriter("/home/limeng/software/alternativeEngine/debug.txt")); }
		 * catch (IOException e) { // TODO Auto-generated catch block
		 * 
		 * e.printStackTrace(); }
		 */
		init = true;
	}

	static boolean init = false;
	static PrintWriter pw;

	public static void output(String e) {
		if (!init)
			init();

		// pw.println(e);
		System.out.println(e);
	}

	public static void output(int e) {
		if (!init)
			init();

		// pw.println(e);

		System.out.println(e);
	}
}
IndexFa.java/   1409452345  1000  1000  100664  1093      `
package Utility;

import java.io.File;
import java.io.IOException;

import Utility.Structuure.ConfigureASEvent;

public class IndexFa {

	public static void indexAll() {
		//ConfigureASEvent.readConfigureFromFile(fileName);
		// String path=ConfigureASEvent.getConfigure().get("conservationPath");
		String path = "/home/limeng/alternative/hg19fasta/";

		File gtf = new File(path);
		String[] names = gtf.list();
		for (String onePath : names) {

			String oneFileName = path + onePath;
			System.out.println(oneFileName);
			if (oneFileName.endsWith("fa")) {
				Process p;
				try {
					p = Runtime.getRuntime().exec(
							"/usr/bin/samtools faidx " + oneFileName);

					Thread.sleep(2 * 1000);

					//System.out.println(oneFileName);
					p.waitFor();

				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

			}
			// index(oneFileName);
			// System.

		}

	}

	public static void main(String[] args) {
		indexAll();
		
		
	}

}

/744            1404006139  1000  1000  100664  2627      `
package Test;

import java.io.File;
import java.util.ArrayList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

import Utility.Structuure.ConfigureASEvent;
import ASEvent.ASEventBrowserExons;
import ASEvent.ASevent;

public class TestInputExons {

	void test() {

		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		DocumentBuilder db = null;

		try {
			db = dbf.newDocumentBuilder();
		} catch (ParserConfigurationException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}

		// System.out.println(x);
		Document doc = db.newDocument();

		// Document doc = db.parse(new File("meng.xml"));
		Element tableRoot = doc.createElement("root");
		doc.appendChild(tableRoot);

		ArrayList<ASevent> table = new ArrayList<ASevent>();

		try {

			ASevent p = new ASEventBrowserExons(
					"chr17:7572927:7573008:-@chr17:7573927:7574033:-:Splice@chr17:7576853:7576926:-@chr17:7577019:7577155:-:Splice@chr17:7577499:7577608:-@chr17:7578177:7578289:-@chr17:7578371:7578544:-@chr17:7579312:7579590:-@chr17:7579700:7579721:-@chr17:7579839:7579912:-",
					"hg19");
			p.init();
			p.processXML(doc, tableRoot);

			table.add(p);
		} catch (Exception e) {
			System.out.println(e.getMessage());
			System.out.println(e.getStackTrace());

		}

		outputXML(doc, "all.xml");

	}

	void outputXML(Document doc, String fileName) {
		TransformerFactory transformerFactory = TransformerFactory
				.newInstance();
		Transformer transformer;
		try {
			transformer = transformerFactory.newTransformer();

			DOMSource source = new DOMSource(doc);
			StreamResult result = new StreamResult(new File(fileName));

			// Output to console for testing
			// StreamResult result = new StreamResult(System.out);

			transformer.transform(source, result);
		} catch (TransformerConfigurationException e) {
			System.out.println(e.getMessage());
		} catch (TransformerException e) {
			System.out.println(e.getMessage());
		}
	}

	public static void main(String[] args) {
		String configureFileName = "/home/limeng/alternative/Configure.txt";

		ConfigureASEvent.readConfigureFromFile(configureFileName);

		TestInputExons t = new TestInputExons();
		t.test();

	}

}

/765            1404634973  1000  1000  100664  2938      `
package Test;

import java.io.File;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

import Utility.ASDebug;
import Utility.Structuure.ConfigureASEvent;
import ASEvent.ASEventBrowserTranscriptID;
import ASEvent.ASevent;
import ASEvent.GetTranscirpts;

public class TestInputID {

	void test(String eventId) {

		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		DocumentBuilder db = null;

		try {
			db = dbf.newDocumentBuilder();
		} catch (ParserConfigurationException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}

		// System.out.println(x);
		Document doc = db.newDocument();

		// Document doc = db.parse(new File("meng.xml"));
		Element tableRoot = doc.createElement("root");
		doc.appendChild(tableRoot);

		// ArrayList<ASevent> table = new ArrayList<ASevent>();
		// String eventId="ENST00000392322@8";

		ASevent p = new ASEventBrowserTranscriptID(eventId, "hg19");
		p.init();
		String ensemblID = p.id;
		Element eventNode = p.processXML(doc, tableRoot);

		GetTranscirpts t = new GetTranscirpts();
		t.getTranscripts(ensemblID, "hg19");
		t.processXMLTranscripts(doc, eventNode);

		// table.add(p);
		outputXML(doc, "/home/limeng/alternative/browserhome/"+eventId + ".xml");
		ASDebug.close();

	}

	void outputXML(Document doc, String fileName) {
		TransformerFactory transformerFactory = TransformerFactory
				.newInstance();
		Transformer transformer;
		try {
			transformer = transformerFactory.newTransformer();

			DOMSource source = new DOMSource(doc);
			StreamResult result = new StreamResult(new File(fileName));

			// Output to console for testing
			// StreamResult result = new StreamResult(System.out);

			transformer.transform(source, result);
		} catch (TransformerConfigurationException e) {
			System.out.println(e.getMessage());
		} catch (TransformerException e) {
			System.out.println(e.getMessage());
		}
	}

	public static void run(String[] args) {
		// args[0]="ENST00000413465@2:3";
		// args[1]="/home/limeng/software/alternativeEngine/Configure.txt";

		// String configureFileName = args[1];

		ConfigureASEvent.readConfigureFromFile(args[1]);

		TestInputID t = new TestInputID();

		t.test(args[0]);

	}

	public static void main(String[] args) {
		//run(args);

		
		  String configureFileName = "/home/limeng/alternative/Configure.txt";
		  
		  ConfigureASEvent.readConfigureFromFile(configureFileName);
		  
		  TestInputID t=new TestInputID();
		  
		  t.test("ENST00000369781@6");
		 
	}

}
/783            1406362960  1000  1000  100664  2091      `
package Test;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import Utility.Algorithm.ASRandom;
import Utility.Algorithm.Translate;
import Utility.Structuure.ConfigureASEvent;

public class Test2014_6_9 {

	public static void main(String[] args) {
		try {
			String configureFileName = "/home/limeng/alternative/Configure.txt";

			ConfigureASEvent.readConfigureFromFile(configureFileName);

			PrintWriter pw = new PrintWriter(new FileWriter(
					"refseq.hg19.genomic.fa.result"));

			String fileName = "/home/limeng/Downloads/refseq.hg19.genomic.fa";

			File file = new File(fileName);
			BufferedReader input;
			input = new BufferedReader(new FileReader(file));

			String text;
			String seq = "";

			text = input.readLine();
			int lineNum = 0;

			while ((text = input.readLine()) != null) {
				// lineNum++;

				// System.out.println(lineNum);
				// if(lineNum>1000)
				// break;
				if (lineNum++ % 100 == 0) {
					System.out.println(lineNum);

				}

				if (text.startsWith(">")) {
					String protein = Translate.translate(seq);
					seq = "";

					String newName = "";

					String[] arrLine = text.split(" ");
					for (int i = 0; i < arrLine.length; ++i) {
						newName += arrLine[i];
						if (i == 0) {
							newName += "_" + ASRandom.randomCharGenerator(20)
									+ " ";
						} else {
							newName += " ";

						}

					}

					// System.out.println(protein);
					pw.println(newName);
					pw.println(protein);

					// ArrayList<String>
					// pfams=PfamEngine.getPfamLocally(protein);
					// pw.println(text);
					// for(String ite:pfams){
					// pw.println(ite);
					// }
					// pw.flush();

					// continue;
				}

				// seq+=text.substring(0, text.length());
				else {
					seq += text;
				}
			}
			pw.close();
			input.close();

		} catch (FileNotFoundException e) {
			System.out.println(e.getMessage());
		} catch (IOException e) {
			System.out.println(e.getMessage());
		}
	}
}

/802            1406363011  1000  1000  100664  2924      `
package Test;

import java.io.File;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

import ASEvent.ASEventMiso;
import ASEvent.ASevent;
import Utility.ASDebug;
import Utility.Structuure.ConfigureASEvent;

public class TestInputMiso {
	void test(String eventId) {

		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		DocumentBuilder db = null;

		try {
			db = dbf.newDocumentBuilder();
		} catch (ParserConfigurationException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}

		// System.out.println(x);
		Document doc = db.newDocument();

		// Document doc = db.parse(new File("meng.xml"));
		Element tableRoot = doc.createElement("root");
		doc.appendChild(tableRoot);

		// ArrayList<ASevent> table = new ArrayList<ASevent>();
		// String eventId="ENST00000392322@8";

		ASevent p = new ASEventMiso(eventId, "hg19");
		p.init();
		//String ensemblID = p.id;
		//Element eventNode = 
		p.processXML(doc, tableRoot);

		// GetTranscirpts t=new GetTranscirpts();
		// t.getTranscripts(ensemblID, "hg19");
		// t.processXMLTranscripts(doc,eventNode);

		// table.add(p);
		outputXML(doc, "/home/limeng/alternative/browserhome/" + "testMiso" + ".xml");
		ASDebug.close();

	}

	void outputXML(Document doc, String fileName) {
		TransformerFactory transformerFactory = TransformerFactory
				.newInstance();
		Transformer transformer;
		try {
			transformer = transformerFactory.newTransformer();

			DOMSource source = new DOMSource(doc);
			StreamResult result = new StreamResult(new File(fileName));

			// Output to console for testing
			// StreamResult result = new StreamResult(System.out);

			transformer.transform(source, result);
		} catch (TransformerConfigurationException e) {
			System.out.println(e.getMessage());
		} catch (TransformerException e) {
			System.out.println(e.getMessage());
		}
	}

	public static void run(String[] args) {
		// args[0]="ENST00000413465@2:3";
		// args[1]="/home/limeng/software/alternativeEngine/Configure.txt";

		// String configureFileName = args[1];

		ConfigureASEvent.readConfigureFromFile(args[1]);

		TestInputMiso t = new TestInputMiso();

		t.test(args[0]);

	}

	public static void main(String[] args) {
		// run(args);

		String configureFileName = "/home/limeng/alternative/Configure.txt";

		ConfigureASEvent.readConfigureFromFile(configureFileName);

		TestInputMiso t = new TestInputMiso();

		t.test("chr19:54780155:54780101|54780118:-@chr19:54779805:54779857:-");

	}

}
/822            1406815340  1000  1000  100664  1291      `
package Test;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

public class TestReadFile {

	public static void main(String[] args) {
		String text="";
		int line = 1;

		try {
			PrintWriter pw = new PrintWriter(new FileWriter(
					"merge_novel.vcf"));

			File file = new File(
					"/media/Elements/zhujingde/exon-capture/vcf/merge.vcf");
			BufferedReader input;

			input = new BufferedReader(new FileReader(file));


			while ((text = input.readLine()) != null) {
				//if (line > 2)
				//	break;
				// System.out.println(text);
				if(text.startsWith("#"))
					continue;
				
				
				String[] arr = text.split("\t");
				//System.out.println(arr[3]);
				//System.out.println(arr[13]);
				if(arr[2].startsWith("rs"))
						continue;
			
				
				line++;
				
			}
			input.close();
			pw.close();
			
		} catch (FileNotFoundException e) {
			System.out.println(e.getMessage());
			System.out.println(text);
		} catch (IOException e) {
			System.out.println(e.getMessage());
			System.out.println(text);
		}catch(Exception e){
			System.out.println(e);
			System.out.println(text);
			System.out.println(line);
			
		}

	}

}

GenXML.java/    1406362972  1000  1000  100664  3864      `
package Test;

import java.io.File;
import java.util.regex.Pattern;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

import Utility.ASDebug;
import Utility.Structuure.ConfigureASEvent;
import ASEvent.ASEventBrowserExons;
import ASEvent.ASEventBrowserTranscriptID;
import ASEvent.ASEventMiso;
import ASEvent.ASevent;
import ASEvent.GetTranscirpts;

public class GenXML {

	static boolean isMiso(String input) {
		if (Pattern.matches(ASEventMiso.regexCasseteExon,
				input.subSequence(0, input.length())))
			return true;
		else if (Pattern.matches(ASEventMiso.regexA5SS,
				input.subSequence(0, input.length())))
			return true;
		else if (Pattern.matches(ASEventMiso.regexA3SS,
				input.subSequence(0, input.length())))
			return true;
		else if (Pattern.matches(ASEventMiso.regexRetainedIntro,
				input.subSequence(0, input.length())))
			return true;

		return false;

	}

	static boolean isID(String input) {
		if (input.startsWith("ENST"))
			return true;
		if (input.startsWith("uc"))
			return true;
		if (input.startsWith("NM"))
			return true;

		return false;
	}

	static void test(String eventId,String fileName) {		
		//eventId.replace(" ", "+");
		
		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		DocumentBuilder db = null;

		try {
			db = dbf.newDocumentBuilder();
		} catch (ParserConfigurationException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}

		// System.out.println(x);
		Document doc = db.newDocument();

		// Document doc = db.parse(new File("meng.xml"));
		Element tableRoot = doc.createElement("root");
		doc.appendChild(tableRoot);

		// ArrayList<ASevent> table = new ArrayList<ASevent>();
		// String eventId="ENST00000392322@8";

		if (isID(eventId)) {
			ASevent p = new ASEventBrowserTranscriptID(eventId, "hg19");
			p.init();
			String ensemblID = p.id;
			// ASDebug.output("1");
			Element eventNode = p.processXML(doc, tableRoot);

			GetTranscirpts t = new GetTranscirpts();
			t.getTranscripts(ensemblID, "hg19");
			t.processXMLTranscripts(doc, eventNode);
		} else if (isMiso(eventId)) {
			ASevent p = new ASEventMiso(eventId, "hg19");
			p.init();
			p.processXML(doc, tableRoot);

		} else {
			ASevent p = new ASEventBrowserExons(eventId,"hg19");
			p.init();
			p.processXML(doc, tableRoot);

		}
		
		outputXML(doc, "/var/www/browserhome/userXML/" + fileName + ".xml");
		ASDebug.close();

	}

	static void outputXML(Document doc, String fileName) {
		TransformerFactory transformerFactory = TransformerFactory
				.newInstance();
		Transformer transformer;
		try {
			transformer = transformerFactory.newTransformer();

			DOMSource source = new DOMSource(doc);
			StreamResult result = new StreamResult(new File(fileName));

			// Output to console for testing
			// StreamResult result = new StreamResult(System.out);

			transformer.transform(source, result);
		} catch (TransformerConfigurationException e) {
			System.out.println(e.getMessage());
		} catch (TransformerException e) {
			System.out.println(e.getMessage());
		}
	}

	public static void run(String[] args) {

		ConfigureASEvent.readConfigureFromFile(args[1]);

		test(args[0],args[2]);

	}

	public static void main(String[] args) {
		run(args);

		// String configureFileName = "/home/limeng/alternative/Configure.txt";

		// ConfigureASEvent.readConfigureFromFile(configureFileName);

		// test("ENST00000510385@6","ENST00000510385@6");

	}

}
